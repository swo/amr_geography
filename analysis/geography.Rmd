---
title: "Theory of use-resistance relationships over geographic scales"
author: "Scott Olesen"
output:
  pdf_document: default
header-includes:
    - \usepackage{bm}
    - \usepackage{mathrsfs}
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
  fig.width=7, fig.height=4, fig.path='fig/',
  dev=c('pdf', 'png'),
  echo=FALSE, warning=FALSE, message=FALSE,
  cache=TRUE, autodep=TRUE)
pdf.options(useDingbats=FALSE, useKerning=FALSE)

library(kableExtra)
```

# Nested model schematic

```{r patch_viz_helpers}
#swo: these are actually useful functions
ring_dist = function(i, j, n) pmin(abs(i - j), n - abs(i - j))

beta_ij = function(i, j, n, epsilon) {
  num = epsilon ** ring_dist(i, j, n)
  den = sum(epsilon ** ring_dist(0, 0:(n - 1), n))
  num / den
}
```

```{r patch_viz}
circle = function(cx, cy, r, n = 100) {
  theta = seq(0, 2 * pi, length.out = n)
  
  data_frame(
    order = 1:n,
    x = cx + r * cos(theta),
    y = cy + r * sin(theta)
  )
}

wedges_f = function(cx, cy, r, n_wedge, n_arc = 100) {
  if (n_wedge == 1) {
    theta = seq(0, 2 * pi, length.out = n_arc)
    return(data_frame(
      wedge = 1,
      x = cx + r * cos(theta),
      y = cy + r * sin(theta)
    ))
  }
  
  thetas = function(i) {
    2 * pi * seq((i - 1.5) / n_wedge, (i - 0.5) / n_wedge, length.out = n_arc)
  }
  
  data_frame(wedge = 1:n_wedge) %>%
    mutate(data = map(wedge, ~ data_frame(
      x = cx + r * c(0, cos(thetas(.))),
      y = cy + r * c(0, sin(thetas(.)))
    ))) %>%
    unnest()
}

ring_scale = Vectorize(function(i, n, scale = 1.0) {
  if (n == 1) return(0)
  
  # rescale so that i=1 -> -scale, i=max dist -> +scale
  dists = ring_dist(1, 1:n, n)
  approx(x = c(min(dists), max(dists)),
         y = scale * c(-1, 1),
         xout = ring_dist(i, 1, n))$y
})

ring_viz = function(n_wedge, r, R = 1.0) {
  n_circle = length(n_wedge)
  
  centers = data_frame(
    center = 1:n_circle,
    n_wedge = n_wedge,
    center_theta = seq(0, 2 * pi, length.out = n_circle + 1) %>% head(-1),
    center_x = R * cos(center_theta),
    center_y = R * sin(center_theta)
  )
  
  circles = centers %>%
    mutate(circles = map2(center_x, center_y, ~ circle(.x, .y, r))) %>%
    select(center, circles) %>%
    unnest()
  
  wedges = centers %>%
    mutate(data = pmap(list(cx = center_x, cy = center_y, r, n_wedge), wedges_f)) %>%
    select(center, data) %>%
    unnest() %>%
    mutate(group = interaction(center, wedge)) %>%
    mutate(fill = 1 * ring_scale(center, n_circle) + 1 * ring_scale(wedge, n_wedge))
  
  edges = crossing(
    center_i = 1:n_circle, center_j = 1:n_circle
  ) %>%
    filter(center_i < center_j) %>%
    left_join(select(centers, center_i = center, x = center_x, y = center_y), by = 'center_i') %>%
    left_join(select(centers, center_j = center, xend = center_x, yend = center_y), by = 'center_j')
  
  ggplot(NULL, aes(x, y)) +
    geom_segment(data = edges, aes(xend = xend, yend = yend), size = 1, color = 'black') +
    geom_path(data = circles, aes(group = center), color = 'black', size = 2) +
    geom_polygon(data = wedges, aes(group = group, fill = fill), color = 'black') +
    coord_fixed() +
    scale_fill_distiller(direction = 1, palette = 'Oranges', guide = 'none') +
    theme_void()
}

multipop_diagram = ring_viz(rep(1, 4), 0.5)
nested_diagram = ring_viz(rep(6, 4), 0.5)

ggsave('fig/multipop_diagram.png', plot = multipop_diagram)
ggsave('fig/nested_diagram.png', plot = nested_diagram)

png('fig/combined_diagram.png')
ggpubr::ggarrange(multipop_diagram, nested_diagram,
  labels = c('a)', 'b)'))
dev.off()
```

# Within-host neutral (WHN) model

```{r whn_parameters}
whn_base_parms = list(
  beta = 4.0,
  u = 1.0,
  tau50 = 1.5 / 12
)

# swo: always using davies base parms, so just bake those into the cost function?
# tau50 is the tau at which resistance prevalence is 50%
cost_function = function(beta, u, tau50) {
  k = 1.0
  
  1/2*(3*beta*k*tau50 - (3*k - 2)*tau50^2 - (k - 2)*u^2 + (beta*k - 4*(k - 1)*tau50)*u - 
    sqrt(beta^2*k^2*tau50^2 + (k^2 - 4*k + 4)*tau50^4 + (k^2 - 4*k + 4)*u^4 - 2*(beta*k^2 -
    2*beta*k)*tau50^3 - 2*(beta*k^2 - 2*beta*k + 8*(k - 1)*tau50)*u^3 + (beta^2*k^2 -
    2*(k^2 + 12*k - 12)*tau50^2 + 2*(beta*k^2 + 6*beta*k)*tau50)*u^2 - 2*(beta^2*k^2*tau50 +
    8*(k - 1)*tau50^3 - (beta*k^2 + 6*beta*k)*tau50^2)*u))/(beta*k*tau50 - k*tau50^2 - k*u^2 +
    (beta*k - 2*k*tau50)*u)
}

whn_base_parms$cost = with(
  whn_base_parms,
  cost_function(beta, u, tau50)
)

whn_base_parms %>%
  as_tibble() %>%
  kable(caption = 'WHN model parameters')
```

## WHN single-population model

**swo** reproduce the original Davies figure here

## WHN multi-population model

```{r whn_sim}
# vector to data frame
whn_unpack = function(x) {
  matrix(x, ncol = 4) %>%
    as_tibble() %>%
    setNames(c('X', 'S', 'R', 'D'))
}

# data frame to vector
whn_pack = function(df) {
  stopifnot(names(df) == c('X', 'S', 'R', 'D'))
  unlist(df)
}

whn_ode_func = function(t, state_vector, parms) {
  state = whn_unpack(state_vector)
  
  with(c(state, parms), {
    n_pop = nrow(state)
    stopifnot(dim(betaij) == rep(n_pop, 2))
    
    N = X + S + R + D
    
    dS = (betaij %*% ((S + D) / N)) * X - (u + taui) * S - (1 - cost) * (betaij %*% (R / N)) * S
    dR = (1 - cost) * (betaij %*% (R / N)) * X - u * R + taui * D
    dD = (1 - cost) * (betaij %*% (R / N)) * S - (u + taui) * D
    dX = -(dS + dR + dD)
    
    list(c(dX, dS, dR, dD))
  })
}

whn_sim = function(taui, epsilon) {
  n_pop = length(taui)

  parms = with(whn_base_parms, {
    betaij = matrix(beta * epsilon / n_pop, ncol = n_pop, nrow = n_pop)
    diag(betaij) <- beta * (1 - epsilon * (1 - 1 / n_pop))
    
    stopifnot(all(rowSums(betaij) == beta))
    stopifnot(all(colSums(betaij) == beta))
    
    c(whn_base_parms, list(
      taui = taui, epsilon = epsilon,
      betaij = betaij
    ))
  })
  
  state = data_frame(
    X = rep(0.990 / n_pop, n_pop),
    S = rep(0.005 / n_pop, n_pop),
    R = S,
    D = 0
  )
  
  state_vector = whn_pack(state)
  
  result = rootSolve::runsteady(state_vector, func = whn_ode_func, parms = parms)
  
  result$y %>%
    whn_unpack() %>%
    mutate(tau = taui,
           pop = seq_along(taui),
           rho = R / (S + R + D))
}
```

```{r whn_results}
whn1 = crossing(
  n_pop = c(4, 8, 16),
  epsilon = c(0, 0.01, 0.1, 0.2, 1.0)
) %>%
  mutate(taui = map(n_pop, ~ seq(0.05, 0.2, length.out = .)),
         results = map2(taui, epsilon, whn_sim))
```

```{r whn_slopes}
whn_multipop_plot = whn1 %>%
  unnest() %>%
  ggplot(aes(taui, rho, color = factor(epsilon))) +
  facet_grid(~ n_pop) +
  geom_point() +
  geom_line()

whn_multipop_plot

ggsave('fig/whn_multipop.png', plot = whn_multipop_plot)

whn1 %>%
  mutate(linear_model = map(results, ~ lm(rho ~ tau, data = .)),
         slope = map_dbl(linear_model, ~ coef(.)['tau'])) %>%
  mutate_at('slope', ~ round(. * 100)) %>%
  select(n_pop, epsilon, slope) %>%
  spread(n_pop, slope) %>%
  kable(caption = 'Slopes measured in WHN multi-population model')
```

## WHN nested populations

```{r whn_nest_sim}
whn_nest_sim = function(taui, eps_super, eps_sub) {
  n_pop = length(taui)
  pop_per = sqrt(n_pop)
  
  if (pop_per != as.integer(pop_per)) {
    stop('length of taui must be a perfect square')
  }
  
  superpop = rep(1:pop_per, each = pop_per)
  stopifnot(length(superpop) == length(taui))
  
  contact = outer(1:n_pop, 1:n_pop, Vectorize(function(i, j) {
    if (i == j) {
      (1 - eps_super * (1 - 1 / pop_per)) * (1 - eps_sub * (1 - 1 / pop_per))
    } else if (superpop[i] == superpop[j]) {
      (1 - eps_super * (1 - 1 / pop_per)) * eps_sub / pop_per
    } else {
      eps_super / pop_per * 1 / pop_per
    }
  }))

  stopifnot(all.equal(rowSums(contact), rep(1.0, n_pop)))
  stopifnot(all.equal(colSums(contact), rep(1.0, n_pop)))

  parms = with(whn_base_parms, {
    betaij = beta * contact
    
    c(whn_base_parms, list(
      taui = taui, eps_super = eps_super, eps_sub = eps_sub,
      betaij = betaij
    ))
  })
  
  state = data_frame(
    X = rep(0.990 / n_pop, n_pop),
    S = rep(0.005 / n_pop, n_pop),
    R = S,
    D = 0
  )
  
  state_vector = whn_pack(state)
  
  result = rootSolve::runsteady(state_vector, func = whn_ode_func, parms = parms)
  
  result$y %>%
    whn_unpack() %>%
    mutate(pop = seq_along(taui),
           superpop = superpop[pop],
           tau = taui,
           rho = R / (S + R + D))
}
```

```{r whn_nest_results}
taui = rep(seq(0.07, 0.18, length.out = 4), each = 4) + 0.02 * rep(seq(-1, 1, length.out = 4), 4)

nest_results = crossing(
  eps_super = c(0.0, 0.01, 0.1, 0.5),
  eps_sub = c(0.0, 0.01, 0.1, 0.5)
) %>%
  filter(eps_super <= eps_sub) %>%
  mutate(data = map2(eps_super, eps_sub, ~ whn_nest_sim(taui, .x, .y)))
```

```{r whn_nest_display}
whn_nest_plot = nest_results %>%
  unnest() %>%
  ggplot(aes(tau, rho, color = factor(superpop))) +
  facet_grid(eps_super ~ eps_sub, labeller = labeller(.rows = label_both, .cols = label_both)) +
  geom_hline(yintercept = 0.0) +
  geom_hline(yintercept = 0.5, color = 'gray', linetype = 2) +
  geom_smooth(aes(color = NULL), method = 'lm', se = FALSE, color = 'black', size = 0.5) +
  geom_point() +
  geom_line() +
  ylim(0 - 0.01, 1.01) +
  theme_classic()

whn_nest_plot

ggsave('fig/whn_nest.png', plot = whn_nest_plot)
```

```{r nested_model_uses}
data_frame(
  population = 1:16,
  superpopulation = rep(1:4, each = 4),
  tau = round(taui, 3)
) %>%
  kable(caption = 'Antibiotic use rates in nested models')
```

How do the within-population slopes compare to the cross-population slopes?

```{r nested_model_slopes}
nest_results %>%
  unnest() %>%
  nest(-eps_super, -eps_sub, -superpop) %>%
  mutate(sub_model = map(data, ~ lm(rho ~ tau, data = .)),
         sub_slope = map_dbl(sub_model, ~ coef(.)['tau']),
         super_tau = map_dbl(data, ~ mean(.$tau)),
         super_rho = map_dbl(data, ~ mean(.$rho))) %>%
  nest(-eps_super, -eps_sub) %>%
  mutate(super_model = map(data, ~ lm(super_rho ~ super_tau, data = .)),
         super_slope = map_dbl(super_model, ~ coef(.)['super_tau']),
         median_sub_slope = map_dbl(data, ~ median(.$sub_slope)),
         slope_ratio = super_slope / median_sub_slope) %>%
  select(eps_super, eps_sub, super_slope, median_sub_slope, slope_ratio) %>%
  mutate_if(is.numeric, ~ round(., 2)) %>%
  # organize as per ms table
  gather('metric', 'value', super_slope, median_sub_slope, slope_ratio) %>%
  mutate(metric = factor(metric, levels = c('super_slope', 'median_sub_slope', 'slope_ratio'))) %>%
  spread(eps_sub, value) %>%
  arrange(metric, eps_super) %>%
  select(-metric) %>%
  kable(caption = 'Slopes and ratios in the nested WHN model') %>%
  group_rows('Super slope', 1, 4) %>%
  group_rows('Median sub slope', 5, 8) %>%
  group_rows('Ratio', 9, 12)
```

# D-types model

```{r dtypes_parameters}
dtypes_base_parms = list(
  n_d = 16,
  min_mu = 0.5,
  max_mu = 2.0,
  beta = 2.0,
  c_beta = 1.0,
  c_mu = 1.1,
  k = 15.0
)

dtypes_base_parms %>%
  as_tibble() %>%
  kable(caption = 'D-types base parameters')

dtypes_base_parms$mu_d = with(dtypes_base_parms,
                             seq(min_mu, max_mu, length = n_d))

dtypes_base_parms %$%
  data_frame(
    d = 1:n_d,
    mu_d = mu_d
  ) %>%
  kable(caption = 'D-types mu_d values')
```

## Single-population model

The original figure uses $\tau = 0.075$.

**swo** make this figure

```{r dtype_helpers}
# pack the list into a vector
dtypes_pack = function(lst) {
  stopifnot(setequal(names(lst), c('X_i', 'S_id', 'R_id')))
  stopifnot(all(dim(lst$S_id) == dim(lst$R_id)))
  stopifnot(dim(lst$S_id)[1] == length(lst$X_i))
  c(lst$X_i, as.vector(lst$S_id), as.vector(lst$R_id))
}

# unpack the vector into a list
dtypes_unpack = function(x, n_pop, n_d) {
  stopifnot(length(x) == n_pop + 2 * (n_d * n_pop))

  x_end = n_pop
  s_start = x_end + 1
  s_end = x_end + n_d * n_pop
  r_start = s_end + 1
  r_end = s_end + n_d * n_pop
  stopifnot(r_end == length(x))

  list(X_i = x[1:x_end],
       S_id = matrix(x[s_start:s_end], nrow = n_pop, ncol = n_d),
       R_id = matrix(x[r_start:r_end], nrow = n_pop, ncol = n_d))
}

# for initially packing the data frame into the list
dtypes_df_to_list = function(df) {
  # check we have the right column names
  stopifnot(setequal(names(df), c('population', 'phenotype', 'dtype', 'value')))
  # check we have the right phenotypes
  stopifnot(setequal(df$phenotype, c('S', 'R', 'X')))

  # extract the no. populations and D-types
  n_pop = length(unique(df$population))
  n_d = length(unique(df$dtype))

  # there should be S and R for each pop/D-type combo
  stopifnot(nrow(filter(df, phenotype == 'S')) == n_pop * n_d)
  stopifnot(nrow(filter(df, phenotype == 'R')) == n_pop * n_d)
  # but X for only each pop
  stopifnot(nrow(filter(df, phenotype == 'X')) == n_pop)

  list(X_i = df %>% filter(phenotype == 'X') %$% values,
       S_id = df %>% filter(phenotype == 'S') %$% value %>% matrix(nrow = n_pop, ncol = n_d),
       R_id = df %>% filter(phenotype == 'R') %$% value %>% matrix(nrow = n_pop, ncol = n_d))
}

# for finally unpacking the list into a data frame
dtypes_list_to_df = function(lst) {
  # check for names
  stopifnot(setequal(names(lst), c('X_i', 'S_id', 'R_id')))

  # get dimensions
  n_pop = length(lst$X_i)
  n_d = dim(lst$S_id)[2]

  # check shapes
  stopifnot(all(dim(lst$S_id) == c(n_pop, n_d)))
  stopifnot(all(dim(lst$R_id) == c(n_pop, n_d)))

  X_rows = data_frame(pop = 1:n_pop, phenotype = 'X', dtype = NA, value = lst$X_i) 
  S_rows = crossing(dtype = 1:n_d, pop = 1:n_pop) %>%
    mutate(phenotype = 'S', value = as.vector(lst$S_id))
  R_rows = crossing(dtype = 1:n_d, pop = 1:n_pop) %>%
    mutate(phenotype = 'R', value = as.vector(lst$R_id))

  bind_rows(X_rows, S_rows, R_rows) %>%
    arrange(pop, phenotype, dtype)
}
```

```{r dtypes_sim}
dtypes_ode_func = function(t, state_vector, parms) {
  state = dtypes_unpack(state_vector, n_pop = parms$n_pop, n_d = parms$n_d)

  with(c(state, parms), {
    stopifnot(length(X_i) == n_pop)
    stopifnot(dim(S_id) == c(n_pop, n_d))
    stopifnot(dim(R_id) == c(n_pop, n_d))

    # rowSums are over D-types (second index)
    v_id = (1.0 - ((S_id + R_id) / rowSums(S_id + R_id) - 1.0 / n_d)) ** k
    stopifnot(dim(v_id) == c(n_pop, n_d))

    N_i = X_i + rowSums(S_id + R_id)
    stopifnot(length(N_i) == n_pop)

    # "tau_i * S_id" does sum_i { tau_i S_id }, which is length P vector
    # to multiply by rows, need to do some fancy footwork: "mat %*% diag(row)"
    dS_id = v_id * (beta_ij %*% (S_id / N_i)) * X_i - tau_i * S_id - S_id %*% diag(mu_d)
    dR_id = v_id * (beta_ij %*% (R_id / N_i)) * X_i - c_mu * R_id %*% diag(mu_d)
    dX_i = -rowSums(dS_id + dR_id)

    list(dtypes_pack(list(X_i = dX_i, S_id = dS_id, R_id = dR_id)))
  })
}

dtypes_sim = function(tau_i, epsilon = 0) {
  n_pop = length(tau_i)

  parms = with(dtypes_base_parms, {
    beta_ij = matrix(beta * epsilon / n_pop, ncol = n_pop, nrow = n_pop)
    diag(beta_ij) <- beta * (1 - epsilon * (1 - 1 / n_pop))

    stopifnot(all(rowSums(beta_ij) == beta))
    stopifnot(all(colSums(beta_ij) == beta))

    c(dtypes_base_parms, list(
      n_pop = n_pop, tau_i = tau_i, epsilon = epsilon, beta_ij = beta_ij
    ))
  })
  
  n_d = parms$n_d
  
  state = list(X_i = rep(0.9 / n_pop, n_pop),
               S_id = matrix(0.05 / (n_pop * n_d), nrow = n_pop, ncol = n_d),
               R_id = matrix(0.05 / (n_pop * n_d), nrow = n_pop, ncol = n_d))

  state_vector = dtypes_pack(state)
  stopifnot(all.equal(sum(state_vector), 1))

  result = rootSolve::runsteady(state_vector, func = dtypes_ode_func, parms = parms,
                                stol = 1e-8 / n_pop, rtol = 1e-6 / n_pop, atol = 1e-6 / n_pop)

  result$y %>%
    dtypes_unpack(n_pop = n_pop, n_d = n_d) %>%
    dtypes_list_to_df() %>%
    left_join(data_frame(pop = 1:n_pop, tau = tau_i), by = 'pop')
}
```

## D-types multi-population

```{r dtypes_results}
dtype1 = crossing(
  n_pop = c(4, 8, 16),
  epsilon = c(0, 0.01, 0.1, 0.2, 1.0)
) %>%
  mutate(tau_i = map(n_pop, ~ seq(0.05, 0.2, length.out = .)),
         results = map2(tau_i, epsilon, dtypes_sim))

dtypes_summarize = function(df) {
  df %>%
    group_by(pop, tau, phenotype) %>%
    summarize_at('value', sum) %>%
    ungroup() %>%
    spread(phenotype, value) %>%
    mutate(rho = R / (S + R))
}

dtype1 %>%
  mutate(results = map(results, dtypes_summarize)) %>%
  unnest() %>%
  ggplot(aes(tau_i, rho, color = factor(epsilon))) +
  facet_wrap(~ n_pop) +
  geom_point() +
  geom_line()
```

## D-types nested

```{r dtypes_nest_sim}
dtypes_nest_sim = function(tau_i, eps_super, eps_sub) {
  n_pop = length(tau_i)
  pop_per = sqrt(n_pop)

  # swo: a lot of this code is reproduced, find a way to refactor
  if (pop_per != as.integer(pop_per)) {
    stop('length of taui must be a perfect square')
  }
  
  superpop = rep(1:pop_per, each = pop_per)
  stopifnot(length(superpop) == length(tau_i))
  
  contact = outer(1:n_pop, 1:n_pop, Vectorize(function(i, j) {
    if (i == j) {
      (1 - eps_super * (1 - 1 / pop_per)) * (1 - eps_sub * (1 - 1 / pop_per))
    } else if (superpop[i] == superpop[j]) {
      (1 - eps_super * (1 - 1 / pop_per)) * eps_sub / pop_per
    } else {
      eps_super / pop_per * 1 / pop_per
    }
  }))

  stopifnot(all.equal(rowSums(contact), rep(1.0, n_pop)))
  stopifnot(all.equal(colSums(contact), rep(1.0, n_pop)))

  parms = with(dtypes_base_parms, {
    c(dtypes_base_parms, list(
      beta_ij = beta * contact,
      n_pop = n_pop, tau_i = tau_i,
      eps_super = eps_super, eps_sub = eps_sub
    ))
  })
  
  n_d = parms$n_d
  
  state = list(X_i = rep(0.9 / n_pop, n_pop),
               S_id = matrix(0.05 / (n_pop * n_d), nrow = n_pop, ncol = n_d),
               R_id = matrix(0.05 / (n_pop * n_d), nrow = n_pop, ncol = n_d))

  state_vector = dtypes_pack(state)
  stopifnot(all.equal(sum(state_vector), 1))

  result = rootSolve::runsteady(state_vector, func = dtypes_ode_func, parms = parms,
                                stol = 1e-8 / n_pop, rtol = 1e-6 / n_pop, atol = 1e-6 / n_pop)

  result$y %>%
    dtypes_unpack(n_pop = n_pop, n_d = n_d) %>%
    dtypes_list_to_df() %>%
    left_join(data_frame(pop = 1:n_pop, superpop = superpop[pop], tau = tau_i), by = 'pop')
}
```

```{r dtypes_nest_results}
tau_i = rep(seq(0.07, 0.18, length.out = 4), each = 4) + 0.02 * rep(seq(-1, 1, length.out = 4), 4)

dtypes_nest_results = crossing(
  eps_super = c(0.0, 0.01, 0.1, 0.5),
  eps_sub = c(0.0, 0.01, 0.1, 0.5)
) %>%
  filter(eps_super <= eps_sub) %>%
  mutate(data = map2(eps_super, eps_sub, ~ dtypes_nest_sim(tau_i, .x, .y)))

janky_superpop_f = function(pop) {
  n_superpop = sqrt(length(pop))
  rep(1:n_superpop, each = n_superpop)
}

dtypes_nest_results %>%
  mutate(data = map(data, dtypes_summarize)) %>%
  unnest() %>%
  group_by(eps_super, eps_sub) %>%
  mutate(superpop = janky_superpop_f(pop)) %>%
  ungroup() %>%
  ggplot(aes(tau, rho, color = factor(superpop))) +
  facet_grid(eps_super ~ eps_sub, labeller = labeller(.rows = label_both, .cols = label_both)) +
  geom_hline(yintercept = 0.0) +
  geom_hline(yintercept = 0.5, color = 'gray', linetype = 2) +
  geom_smooth(aes(color = NULL), method = 'lm', se = FALSE, color = 'black', size = 0.5) +
  geom_point() +
  geom_line() +
  ylim(0 - 0.01, 1.01) +
  theme_classic()
```

**swo** create a table of these results analogous to the one for WHN
