---
title: "Geography and associations between antibiotic use and resistance: simulations"
author: "Scott Olesen"
---

```{r global_options, echo = FALSE, message = FALSE}
library(knitr)
library(cowplot)
library(grid)
library(gridExtra)
library(patchwork)
library(magrittr)
library(tidyverse)
library(memoise)

set.seed(5)

memoise <- function(x) memoise::memoise(x, cache = cache_filesystem("cache_memo/"))

pdf.options(useDingbats = FALSE, useKerning = FALSE)

knitr::opts_chunk$set(
  fig.width = 7, fig.height = 4, fig.path = 'fig/',
  dev = c('png', 'pdf'),
  echo = FALSE, warning = FALSE, message = FALSE,
  cache = TRUE, autodep = TRUE)
```

```{r helpers}
annotate_text <- function(x, y, label, parse = TRUE, ...) {
  annotate('text', x = x, y = y, label = label, parse = parse, ...)
}
```

# Within-host neutral (WHN) model

```{r whn_parameters}
whn_base_parms <- list(
  beta = 4.0,
  u = 1.0,
  k = 1.0,
  cost = 0.1683543
)

whn_base_parms %>%
  as_tibble() %>%
  kable(caption = 'WHN model parameters')
```

## WHN single-population model

```{r whn_sim}
# The ODE function only takes a vector, so we need to "unpack" the
# vector into a sensible data frame, compute the ODEs, then "pack"
# the data frame back into a vector.
whn_compartments <- c("X", "S", "R", "SR", "RS")

whn_unpack <- function(x) {
  matrix(x, ncol = length(whn_compartments)) %>%
    as_tibble() %>%
    setNames(whn_compartments)
}

# data frame to vector
whn_pack <- function(df) {
  stopifnot(all(names(df) == whn_compartments))
  unlist(df)
}

whn_ode_func <- function(time_, state_vector, parms) {
  state <- whn_unpack(state_vector)

  with(c(state, parms), {
    N <- X + S + R + SR + RS # total number of individuals

    Stot <- S + SR
    Rtot <- R + RS
    dS <- (betaij %*% (Stot / N))*X - (u + taui)*S - k*(1 - cost)*(betaij %*% (Rtot / N))*S
    dR <- (1 - cost)*(betaij %*% (Rtot / N))*X - u*R - k*(betaij %*% (Stot / N))*R + taui*(SR + RS)
    dSR <- k*(1 - cost)*(betaij %*% (Rtot / N))*S - (u + taui)*SR
    dRS <- k*(betaij %*% (Stot / N))*R - (u + taui)*RS
    dX <- -(dS + dR + dSR + dRS)

    list(c(dX, dS, dR, dSR, dRS))
  })
}

# Check that:
# - All entries in the transmission matrix are nonnegative
# - All rows add up to 1
all_nearly_equal <- function(x, y, tol = 1e-12) all(abs(x - y) < tol)

check_transmission_matrix <- function(mat, size) {
  stopifnot(all(mat >= 0))
  stopifnot(all_nearly_equal(rowSums(mat), 1.0))
  stopifnot(all(dim(mat) == c(size, size)))
  stopifnot(ncol(mat) == size)
  stopifnot(nrow(mat) == size)
}

# Run the simulation
whn_sim <- function(parms) {
  # Check that all the required parameters have been input
  parm_names <- c("beta", "cost", "k", "u", "taui", "transmission_matrix")
  stopifnot(all(parm_names %in% names(parms)))
  
  n_pop <- length(parms$taui)

  new_parms <- with(parms, {
    # check the transmission matrix is square with right row sums
    check_transmission_matrix(transmission_matrix, n_pop)
    betaij <- transmission_matrix * beta

    # Add transmission matrix beta_ij to the parameter list
    `$<-`(parms, "betaij", betaij)
  })

  # Initial state of the simulation
  state <- tibble(
    X = rep(0.990 / n_pop, n_pop),
    S = rep(0.005 / n_pop, n_pop),
    R = S,
    SR = 0,
    RS = 0
  )

  state_vector <- whn_pack(state)

  # Run the simulation
  result <- rootSolve::runsteady(state_vector, func = whn_ode_func, parms = new_parms)

  # Unpack the output state and clean it up
  result$y %>%
    whn_unpack() %>%
    mutate(
      tau = parms$taui,
      pop = seq_along(parms$taui),
      rho = (R + RS) / (S + SR + R + RS)
    )
}

memo_whn_sim <- memoise(whn_sim)
```

To make sure I got the equations right, I reproduce the $k = 1$ line in Davies *et al.* Figure 2g.

```{r davies_repro}
identity_matrix <- function(n) `diag<-`(matrix(0, ncol = n, nrow = n), 1)

n_repro_pop <- 16
repro_parms <- whn_base_parms %>%
  inset2("transmission_matrix", identity_matrix(n_repro_pop)) %>%
  inset2("taui", seq(0, 3 / 12, length.out = n_repro_pop))

whn_repro <- memo_whn_sim(repro_parms)

whn_repro %>%
  ggplot(aes(tau, rho)) +
  geom_point() +
  geom_line() +
  scale_x_continuous(
    name = 'antibiotic tx per month',
    sec.axis = sec_axis(~ . * 12)
  ) +
  ylab('proportion resistant') +
  theme_cowplot()
```

## WHN two-population model

```{r whn_double}
epsilon_matrix <- function(eps) {
  stopifnot(between(eps, 0, 0.5))
  matrix(c(1 - eps, eps, eps, 1 - eps), nrow = 2, ncol = 2)
}

whn_2pop_sim <- function(tau1, tau2, epsilon) {
  parms <- whn_base_parms %>%
    `$<-`("transmission_matrix", epsilon_matrix(epsilon)) %>%
    `$<-`("taui", c(tau1, tau2))
  
  memo_whn_sim(parms)
}

whn_epsilon_values <- c(0, 1e-4, 1e-3, 0.01, 0.0175, 0.025, 0.050, 0.075, 0.1, 0.2, 0.3, 0.4, 0.5)

whn2 <- tibble(
  base_tau = 0.125,
  delta_tau = round(seq(0.0, 0.15, length.out = 7), 3),
  tau1 = base_tau - delta_tau / 2,
  tau2 = base_tau + delta_tau / 2
) %>%
  crossing(epsilon = whn_epsilon_values) %>%
  mutate(
    results = pmap(list(tau1, tau2, epsilon), whn_2pop_sim),
    delta_rho = map_dbl(results, ~ max(.$rho) - min(.$rho))
  )
```

```{r whn_barchart_data}
whn2_plot_data <- whn2 %>%
  unnest(cols = c(results)) %>%
  mutate(pop = recode(pop, `1` = "intervention", `2` = "control")) %>%
  filter(epsilon %in% c(0.0, 0.01, 0.1))
```

```{r whn_barcharts}
whn2_plot_f <- function(df) {
  initial_resistance <- df %>%
    filter(epsilon == 0, pop == 'control') %>%
    pull(rho)

  df %>%
    ggplot(aes(x = factor(epsilon), y = rho, fill = pop)) +
    geom_hline(yintercept = initial_resistance, linetype = 2) +
    geom_col(position = 'dodge', color = 'black') +
    scale_fill_manual(
      '',
      values = c('white', 'black')
    ) +
    scale_x_discrete(name = expression(epsilon)) +
    scale_y_continuous(
      name = 'resistance (%)',
      labels = scales::percent_format(accuracy = 1, suffix = ''),
      limits = c(0, 1.0),
      expand = c(0, 0)
    ) +
    theme_half_open(font_size = 12) +
    theme(
      legend.key.size = unit(3, 'mm'),
      legend.position = c(0.3, 1.03),
      axis.ticks.x = element_blank()
    )
}

whn2_plot1 <- whn2_plot_data %>%
  filter(delta_tau == 0.05) %>%
  whn2_plot_f()

whn2_plot2 <- whn2_plot_data %>%
  filter(delta_tau == 0.10) %>%
  whn2_plot_f()
```

```{r whn_dr_vs_dtau}
whn2_plot3 <- whn2 %>%
  filter(epsilon %in% c(0.0, 0.01, 0.1)) %>%
  ggplot(aes(delta_tau, delta_rho, group = factor(epsilon))) +
  geom_point() +
  geom_line() +
  scale_x_continuous(
    expression(Delta * tau),
    limits = c(0, 0.15),
    expand = c(0, 0.002)
  ) +
  scale_y_continuous(
    expression(Delta * rho),
    limits = c(0, 0.80),
    expand = c(0, 0.01)
  ) +
  annotate_text(0.07, 0.60, "epsilon == 0") +
  annotate_text(0.10, 0.35, "epsilon == 0.01") +
  annotate_text(0.13, 0.12, "epsilon == 0.1") +
  theme_cowplot(font_size = 12)

show(whn2_plot3)
```

```{r whn_drdtau_vs_epsilon}
whn2_plot4 <- whn2 %>%
  filter(
    delta_tau %in% c(0.05, 0.10),
    epsilon %in% c(0, 1e-4, 0.01, 0.025, 0.050, 0.075, 0.1, 0.2, 0.3, 0.4, 0.5)
  ) %>%
  mutate(dr_du = delta_rho / delta_tau) %>%
  ggplot(aes(epsilon, dr_du, group = factor(delta_tau))) +
  geom_point(aes(shape = factor(delta_tau))) +
  geom_line() +
  geom_blank(data = tibble(epsilon = 0, dr_du = 0, delta_tau = 0.01)) +
  scale_shape_manual(
    values = c(1, 16),
    labels = c(
      expression(Delta * tau == 0.05),
      expression(Delta * tau == 0.10)
    )
  ) +
  guides(shape = guide_legend(title = "", label.hjust = 0)) +
  scale_x_continuous(
    expression(epsilon),
    expand = c(0, 0.005)
  ) +
  scale_y_continuous(
    expression(Delta * rho / Delta * tau),
    limits = c(0, 7),
    expand = c(0, 0.1)
  ) +
  theme_cowplot(font_size = 12) +
  theme(legend.position = c(0.5, 0.75))

whn2_plot4
```

```{r whn_double_results}
diagram <- ggdraw() +
  draw_grob(x = 0.2, circleGrob(gp = gpar(fill = "black")), scale = 0.5) +
  draw_grob(x = -0.5, circleGrob(gp = gpar(fill = "white")), scale = 0.5) +
  draw_grob(x = -0.5, y = -0.5, textGrob("control\npopulation", gp = gpar(fontsize = 11))) +
  draw_grob(x = 0.2, y = -0.5, textGrob("intervention\npopulation", gp = gpar(fontsize = 11))) +
  draw_grob(x = 0, y = 0, linesGrob(x = unit(c(0.2, 0.5), "npc"), y = 0.5)) +
  draw_grob(x = -0.15, y = 0.1, textGrob(expression(epsilon), gp = gpar(fontsize = 11))) +
  draw_grob(x = -0.15, y = 0.35, textGrob("interaction\nstrength", gp = gpar(fontsize = 11)))

whn2_plot <- (diagram | whn2_plot1 | whn2_plot2) /
  (whn2_plot3 | whn2_plot4) +
  plot_annotation(
    tag_levels = "a",
    theme = theme(plot.margin = margin())
  )

ggsave(
  'fig/whn2_plot.pdf', whn2_plot,
  width = 190, height = 100, unit = 'mm'
)

ggsave(
  'fig/whn2_plot.png', whn2_plot,
  width = 190, height = 100, unit = 'mm'
)
```

## WHN with commuting

```{r}
shrink_square_mat <- function(mat, n) {
  # matrix must be square
  n0 <- dim(mat)[1]
  stopifnot(dim(mat)[2] == n0)
  # must be asking for fewer columns
  stopifnot(n <= n0)
  
  # get indices to subsample
  idx <- sample(1:n0, n)
  mat[idx, idx]
}

scale_rows <- function(mat) {
  t(scale(t(mat), center = FALSE, scale = rowSums(mat)))
}
grow_diagonal <- function(mat, f) `diag<-`(mat, diag(mat) / f)

movement_counts_to_transmission_matrix <- function(tbl, size = NULL, f_internal = NULL) {
  # check that table has the expected columns
  stopifnot(all(names(tbl) == c("unit1", "unit2", "n")))
  # check that table can be symmetrical
  stopifnot(setequal(tbl$unit1, tbl$unit2))
  # get the names
  nms <- sort(unique(tbl$unit1))
  
  out <- tbl %>%
    arrange(unit1, unit2) %>%
    spread(unit2, n, fill = 0) %T>%
    {
      stopifnot(all(.$unit1 == nms))
      stopifnot(all(names(.) == c("unit1", nms)))
    } %>%
    select(-unit1) %>%
    as.matrix() %>%
    `rownames<-`(nms)
  
  if (!is.null(size)) out %<>% shrink_square_mat(size)
  if (!is.null(f_internal)) out %<>% grow_diagonal(f_internal)
  
  scale_rows(out)
}

size <- 25
trans_datasets <- list(
  eu_flights = read_tsv("../db/europe/flights.tsv") %>%
    rename(unit1 = country1, unit2 = country2, n = n),
  us_commuting = read_tsv("../db/us/commuting.tsv") %>%
    rename(unit1 = from_state, unit2 = to_state, n = n_workers)
)

taui <- sample(seq(0, 3 / 12, length.out = size))

null_parms <- whn_base_parms %>%
  `$<-`("taui", taui) %>%
  `$<-`("transmission_matrix", identity_matrix(size))

results <- crossing(
  trans_data_nm = c("eu_flights", "us_commuting"),
  internal_f = c(1.0, 0.1, 0.01, 0.001)
) %>%
  mutate(
    trans_data = map(trans_data_nm, ~ trans_datasets[[.]]),
    trans_matrix = map2(trans_data, internal_f, ~ movement_counts_to_transmission_matrix(.x, size, .y)),
    parms = map(trans_matrix, ~ `$<-`(null_parms, "transmission_matrix", .))
  ) %>%
  bind_rows(crossing(trans_data_nm = c("eu_flights", "us_commuting"), internal_f = NA, parms = list(null_parms))) %>%
  mutate(sim = map(parms, whn_sim))
```

```{r}
results %>%
  select(trans_data_nm, internal_f, sim) %>%
  unnest() %>%
  ggplot(aes(tau, rho, color = factor(internal_f))) +
  facet_wrap(~ trans_data_nm) +
  geom_smooth(method = "lm", se = FALSE) +
  geom_point()

results %>%
  mutate(
    model_data = map(sim, ~ filter(., between(tau, 0.05, 0.20))),
    model = map(model_data, ~ lm(rho ~ tau, data = .)),
    slope = map_dbl(model, ~ coef(.)["tau"]),
    reduction = 1 - slope / max(slope)
  ) %>%
  select(trans_data_nm, internal_f, slope, reduction) %>%
  arrange(reduction)
```

# D-types model

```{r dtypes_parameters}
dtypes_base_parms <- list(
  n_d = 16,
  min_mu = 0.5,
  max_mu = 2.0,
  beta = 2.0,
  c_beta = 1.0,
  c_mu = 1.1,
  k = 15.0
)

dtypes_base_parms %>%
  as_tibble() %>%
  kable(caption = 'D-types base parameters')

dtypes_base_parms$mu_d <- with(
  dtypes_base_parms,
  seq(min_mu, max_mu, length = n_d)
)

with(
  dtypes_base_parms,
  tibble(
    d = 1:n_d,
    mu_d = mu_d
  )
) %>%
  kable(caption = 'D-types mu_d values')
```

## Single-population model

```{r dtype_helpers}
# pack the list into a vector
dtypes_pack <- function(lst) {
  stopifnot(setequal(names(lst), c('X_i', 'S_id', 'R_id')))
  stopifnot(all(dim(lst$S_id) == dim(lst$R_id)))
  stopifnot(dim(lst$S_id)[1] == length(lst$X_i))
  c(lst$X_i, as.vector(lst$S_id), as.vector(lst$R_id))
}

# unpack the vector into a list
dtypes_unpack <- function(x, n_pop, n_d) {
  stopifnot(length(x) == n_pop + 2 * (n_d * n_pop))

  x_end <- n_pop
  s_start <- x_end + 1
  s_end <- x_end + n_d * n_pop
  r_start <- s_end + 1
  r_end <- s_end + n_d * n_pop
  stopifnot(r_end == length(x))

  list(
    X_i = x[1:x_end],
    S_id = matrix(x[s_start:s_end], nrow = n_pop, ncol = n_d),
    R_id = matrix(x[r_start:r_end], nrow = n_pop, ncol = n_d)
  )
}

# for initially packing the data frame into the list
dtypes_df_to_list <- function(df) {
  # check we have the right column names
  stopifnot(setequal(names(df), c('population', 'phenotype', 'dtype', 'value')))
  # check we have the right phenotypes
  stopifnot(setequal(df$phenotype, c('S', 'R', 'X')))

  # extract the no. populations and D-types
  n_pop <- length(unique(df$population))
  n_d <- length(unique(df$dtype))

  # there should be S and R for each pop/D-type combo
  stopifnot(nrow(filter(df, phenotype == 'S')) == n_pop * n_d)
  stopifnot(nrow(filter(df, phenotype == 'R')) == n_pop * n_d)
  # but X for only each pop
  stopifnot(nrow(filter(df, phenotype == 'X')) == n_pop)

  list(
    X_i = df %>% filter(phenotype == 'X') %>% pull(value),
    S_id = df %>% filter(phenotype == 'S') %>% pull(value) %>% matrix(nrow = n_pop, ncol = n_d),
    R_id = df %>% filter(phenotype == 'R') %>% pull(value) %>% matrix(nrow = n_pop, ncol = n_d)
  )
}

# for finally unpacking the list into a data frame
dtypes_list_to_df <- function(lst) {
  # check for names
  stopifnot(setequal(names(lst), c('X_i', 'S_id', 'R_id')))

  # get dimensions
  n_pop <- length(lst$X_i)
  n_d <- dim(lst$S_id)[2]

  # check shapes
  stopifnot(all(dim(lst$S_id) == c(n_pop, n_d)))
  stopifnot(all(dim(lst$R_id) == c(n_pop, n_d)))

  X_rows <- tibble(pop = 1:n_pop, phenotype = 'X', dtype = NA, value = lst$X_i)
  S_rows <- crossing(dtype = 1:n_d, pop = 1:n_pop) %>%
    mutate(phenotype = 'S', value = as.vector(lst$S_id))
  R_rows <- crossing(dtype = 1:n_d, pop = 1:n_pop) %>%
    mutate(phenotype = 'R', value = as.vector(lst$R_id))

  bind_rows(X_rows, S_rows, R_rows) %>%
    arrange(pop, phenotype, dtype)
}
```

```{r dtypes_sim}
dtypes_ode_func <- function(t, state_vector, parms) {
  state <- dtypes_unpack(state_vector, n_pop = parms$n_pop, n_d = parms$n_d)

  with(c(state, parms), {
    stopifnot(length(X_i) == n_pop)
    stopifnot(dim(S_id) == c(n_pop, n_d))
    stopifnot(dim(R_id) == c(n_pop, n_d))

    # rowSums are over D-types (second index)
    v_id <- (1.0 - ((S_id + R_id) / rowSums(S_id + R_id) - 1.0 / n_d)) ** k
    stopifnot(dim(v_id) == c(n_pop, n_d))

    N_i <- X_i + rowSums(S_id + R_id)
    stopifnot(length(N_i) == n_pop)

    # "tau_i * S_id" does sum_i { tau_i S_id }, which is length P vector
    # to multiply by rows, need to do some fancy footwork: "mat %*% diag(row)"
    dS_id <- v_id * (beta_ij %*% (S_id / N_i)) * X_i - tau_i * S_id - S_id %*% diag(mu_d)
    dR_id <- v_id * (beta_ij %*% (R_id / N_i)) * X_i - c_mu * R_id %*% diag(mu_d)
    dX_i <- -rowSums(dS_id + dR_id)

    list(dtypes_pack(list(X_i = dX_i, S_id = dS_id, R_id = dR_id)))
  })
}

dtypes_sim <- function(parms) {
  stopifnot(
    setequal(
      names(parms),
      c(names(dtypes_base_parms), "tau_i", "transmission_matrix")
    )
  )
  
  n_pop <- length(parms$tau_i)
  check_transmission_matrix(parms$transmission_matrix, n_pop)
  #stopifnot(between(epsilon, 0, 1 - 1 / n_pop))
  
  parms$beta_ij <- with(parms, { beta * transmission_matrix })
  parms$n_pop <- n_pop

  n_d <- parms$n_d
  state <- list(
    X_i = rep(0.9 / n_pop, n_pop),
    S_id = matrix(0.05 / (n_pop * n_d), nrow = n_pop, ncol = n_d),
    R_id = matrix(0.05 / (n_pop * n_d), nrow = n_pop, ncol = n_d)
  )

  state_vector <- dtypes_pack(state)
  stopifnot(all.equal(sum(state_vector), 1))

  result <- rootSolve::runsteady(
    state_vector,
    func = dtypes_ode_func,
    parms = parms,
    stol = 1e-8 / n_pop,
    rtol = 1e-6 / n_pop,
    atol = 1e-6 / n_pop
  )

  result$y %>%
    dtypes_unpack(n_pop = n_pop, n_d = n_d) %>%
    dtypes_list_to_df() %>%
    left_join(tibble(pop = 1:n_pop, tau = parms$tau_i), by = 'pop')
}
```

To ensure I got the equations right, I reproduce Figure 3 with $\tau = 0.075$.

```{r dtypes_repro_bars}
dtypes_repro_parms <- dtypes_base_parms %>%
  `$<-`("tau_i", 0.075) %>%
  `$<-`("transmission_matrix", identity_matrix(1))

dtypes_repro_bars <- dtypes_sim(dtypes_repro_parms)

dtypes_repro_bars %>%
  mutate(mu_d = dtypes_base_parms$mu_d[dtype]) %>%
  ggplot(aes(mu_d, value, fill = phenotype)) +
  geom_col() +
  xlab('Clearance rate') +
  ylab('Strain prevalence') +
  theme_cowplot()
```

Next, I show the jagged line in Figure 4. It may not look exactly right because I ran a limited number of simulations:

```{r dtypes_repro_line}
dtypes_line_n <- 50
dtypes_line_parms <- dtypes_base_parms %>%
  inset2("tau_i", seq(0.04, 0.20, length.out = dtypes_line_n)) %>%
  inset2("transmission_matrix", identity_matrix(dtypes_line_n))

dtypes_repro_line <- dtypes_sim(dtypes_line_parms)

dtypes_repro_line %>%
  group_by(tau) %>%
  summarize(
    f_res = sum(value[phenotype == 'R']),
    f_all = sum(value)
  ) %>%
  mutate(rho = f_res / f_all) %>%
  ggplot(aes(tau, rho)) +
  geom_point() +
  geom_line() +
  theme_cowplot()
```

## D-types two-population

```{r dtypes_double}
dtypes_epsilon_values <- c(0, 1e-4, 0.001, 0.005, 0.01, 0.0175, 0.025, 0.05, 0.075, 0.1)

dtypes_simplify_results <- function(df) {
  df %>%
    group_by(pop, phenotype) %>%
    summarize(
      value = sum(value),
      tau = unique(tau)
    ) %>%
    ungroup() %>%
    spread(phenotype, value) %>%
    mutate(rho = R / (R + S))
}

dtypes_2pop_sim <- function(tau1, tau2, epsilon) {
  parms <- dtypes_base_parms %>%
    `$<-`("transmission_matrix", epsilon_matrix(epsilon)) %>%
    `$<-`("tau_i", c(tau1, tau2))
  
  dtypes_sim(parms) %>%
    dtypes_simplify_results
}

dtypes2 <- tibble(
  base_tau = 0.125,
  delta_tau = c(0.05, 0.10),
  tau1 = base_tau - delta_tau / 2,
  tau2 = base_tau + delta_tau / 2
) %>%
  crossing(epsilon = dtypes_epsilon_values) %>%
  mutate(
    results = pmap(list(tau1, tau2, epsilon), dtypes_2pop_sim),
    delta_rho = map_dbl(results, ~ max(.$rho) - min(.$rho)),
    dr_du = delta_rho / delta_tau
  )
```

```{r dtypes_plot}
dtypes2_plot <- dtypes2 %>%
  ggplot(aes(epsilon, dr_du, group = factor(delta_tau))) +
  geom_point(aes(shape = factor(delta_tau))) +
  geom_line() +
  geom_blank(data = tibble(epsilon = 0, dr_du = 0, delta_tau = 0.01)) +
  scale_shape_manual(
    values = c(1, 16),
    labels = c(
      expression(Delta * tau == 0.05),
      expression(Delta * tau == 0.10)
    )
  ) +
  guides(shape = guide_legend(title = "", label.hjust = 0)) +
  scale_x_continuous(
    expression(epsilon),
    limits = c(0, 0.1),
    expand = c(0.02, 0, 0.05, 0)
  ) +
  scale_y_continuous(
    expression(Delta * rho / Delta * tau),
    limits = c(0, 6.5),
    expand = c(0, 0.1)
  ) +
  theme_cowplot(font_size = 12) +
  theme(legend.position = c(0.5, 0.75))

show(dtypes2_plot)

ggsave(
  'fig/dtypes2_plot.pdf', dtypes2_plot,
  width = 88, height = 80, unit = 'mm'
)

ggsave(
  'fig/dtypes2_plot.png', dtypes2_plot,
  width = 88, height = 80, unit = 'mm'
)
```

## D-types with commuting

```{r}
tau_i <- sample(seq(0.04, 0.20, length.out = size))

null_parms <- dtypes_base_parms %>%
  `$<-`("tau_i", tau_i) %>%
  `$<-`("transmission_matrix", identity_matrix(size))

results <- crossing(
  trans_data_nm = c("eu_flights", "us_commuting"),
  internal_f = c(1.0, 0.1, 0.01, 0.001)
) %>%
  mutate(
    trans_data = map(trans_data_nm, ~ trans_datasets[[.]]),
    trans_matrix = map2(trans_data, internal_f, ~ movement_counts_to_transmission_matrix(.x, size, .y)),
    parms = map(trans_matrix, ~ `$<-`(null_parms, "transmission_matrix", .))
  ) %>%
  bind_rows(crossing(trans_data_nm = c("eu_flights", "us_commuting"), internal_f = NA, parms = list(null_parms))) %>%
  mutate(
    sim_raw = map(parms, dtypes_sim),
    sim = map(sim_raw, dtypes_simplify_results)
  )

results %>%
  select(trans_data_nm, internal_f, sim) %>%
  unnest() %>%
  ggplot(aes(tau, rho, color = factor(internal_f))) +
  facet_wrap(~ trans_data_nm) +
  geom_point() +
  geom_line()

results %>%
  mutate(
    model = map(sim, ~ lm(rho ~ tau, data = .)),
    slope = map_dbl(model, ~ coef(.)["tau"]),
    reduction = 1 - slope / max(slope)
  ) %>%
  select(trans_data_nm, internal_f, slope, reduction) %>%
  arrange(reduction)
```

# Reduction in $\Delta \rho / \Delta \tau$ against $\epsilon$

```{r reduction}
bind_rows(
  'WHN' = whn2,
  'Dtypes' = dtypes2,
  .id = 'model'
) %>%
  mutate(
    dr_du = delta_rho / delta_tau,
    key = str_c(model, ' Δτ=', delta_tau)
  ) %>%
  filter(
    delta_tau %in% c(0.05, 0.10),
    epsilon %in% c(0, 1e-4, 1e-3, 1e-2, 1e-1)
  ) %>%
  group_by(model, delta_tau) %>%
  mutate(pct_red = scales::percent(1 - dr_du / dr_du[epsilon == 0], 0.1)) %>%
  ungroup() %>%
  select(epsilon, key, pct_red) %>%
  spread(key, pct_red) %>%
  kable(caption = 'Percent reduction, compared to ε=0')
```
