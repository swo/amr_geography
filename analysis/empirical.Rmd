---
title: "Empirical use-resistance relationships over geographic scales"
author: "Scott Olesen"
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
  fig.width=7, fig.height=4, fig.path='fig/',
  dev=c('png', 'pdf'),
  echo=FALSE, warning=FALSE, message=FALSE,
  cache=TRUE, autodep=TRUE)
pdf.options(useDingbats=FALSE, useKerning=FALSE)

state_map = map_data('state')
map = purrr::map

library(boot)
```

# Methods

## US/Europe conversions

**swo** Un-convert these results, since there's no need to get everything on the same scale.

Most of the US studies and data are measured in prescriptions (or claims) per 1,000 people per year (PIY); the European studies are usually in DID (DDD per 1,000 people per year). Converting between the two requires asserting how many DDD are in one prescription.

I got these numbers by (1) looking in MarketScan and computing the average days' supply for claims for each drug and (2) comparing the CDDEP's within-US numbers (in PIY) with their across-country values for the US (in DID). They seem to disagree somewhat on the $\beta$-lactams. Something to be looked into a little more.

```{r piy_did}
us_europe_crosswalk = data_frame(
  drug = c('beta_lactam', 'quinolone', 'macrolide'),
  ddd_per_rx = c(10, 10, 7)
)

kable(us_europe_crosswalk)

# PIY = Prescriptions per 1,000 Inhabitants per Year
us_europe_convert = function(drug_, piy) {
  us_europe_crosswalk %$%
    { piy / 365 * ddd_per_rx[match(drug_, drug)] }
}
```

## Data

#### Medicare & ResistanceOpen

```{r medicare_ro}
ro_bugdrugs = data_frame(
  bug = c('S. pneumoniae', 'S. pneumoniae', 'E. coli'),
  drug_group = c('beta_lactam', 'macrolide', 'quinolone')
)

ro_state = read_tsv('../data/ms-medicare-ro/abg_state.tsv')
ro_hrr = read_tsv('../data/ms-medicare-ro/abg_hrr.tsv')
```

### MarketScan

```{r maup_db}
state_census = read_tsv('../db/state_census.tsv')
```

```{r marketscan_data}
marketscan_res = read_tsv('~/grad/proj/medicare/analysis/ms2/data/abg_state.tsv') %>%
  rename(drug=drug_group) %>%
  mutate(bugdrug = case_when(
    .$bug == 'E. coli' & .$drug == 'quinolone' ~ 'Ec/q',
    .$bug == 'S. pneumoniae' & .$drug == 'beta_lactam' ~ 'Sp/bl',
    .$bug == 'S. pneumoniae' & .$drug == 'macrolide' ~ 'Sp/m'
  )) %>%
  filter(!is.na(bugdrug)) %>%
  mutate(n_resistant = as.integer(round(f_ns * n_isolates))) %>%
  select(bugdrug, drug, state, n_resistant, n_isolates)

marketscan_use = read_tsv('~/grad/proj/medicare/analysis/ms2/ineq_marketscan.tsv') %>%
  rename(drug = drug_group) %>%
  filter(drug %in% c('quinolone', 'beta_lactam', 'macrolide')) %>%
  mutate(did = us_europe_convert(drug, total_use * 1000))

marketscan = marketscan_use %>%
  inner_join(marketscan_res, by=c('drug', 'state')) %>%
  rename(unit = state) %>%
  left_join(select(state_data, unit, population), by = 'unit') %>%
  select(unit, bugdrug, did, n_resistant, n_isolates, population)
```

### ECDC

```{r ecdc}
rename_bug = function(x) {
  sapply(x, function(y) {
    switch(y, 'Escherichia coli'='E. coli', 'Streptococcus pneumoniae'='S. pneumoniae', y)
  })
}

ecdc = read_tsv('../data/ecdc/data.tsv') %>%
  mutate(bug = rename_bug(bug),
         pct_res = 100 * f_ns,
         dataset='ECDC') %>%
  select(dataset, bug, drug, geo_unit = country, did, n_resistant = n_ns, n_isolates, pct_res)
```

### NHSN/IMS

```{r nhsn_ims}
nhsn = read_tsv('../data/nhsn-ims/data.tsv') %>%
  mutate(dataset='NHSN/IMS', bug='E. coli', drug='quinolone',
         pct_res = 100 * n_resistant / n_isolates,
         did = us_europe_convert(drug, rx_1k_year)) %>%
  select(dataset, bug, drug, geo_unit=state, did, pct_res, n_isolates)
```

# Results

## MarketScan

```{r marketscan_maup_setup}
# group n items into k groups, with at least n_min items in each group
sample_nmin = function(n, k, n_min = 2) {
  stopifnot(n_min * k <= n)
  sample(c(rep(1:k, each = n_min), sample(1:k, n - (n_min * k), replace = TRUE)))
}

renumber = function(x) match(x, unique(x))

# given distances between things, create groups
random_zones = function(distances, k) {
  stopifnot(nrow(distances) == ncol(distances))
  stopifnot(nrow(distances) >= k)
  
  centers = sample(1:nrow(distances), k)
  zones = distances[, centers] %>%
    apply(1, function(x) centers[which.min(x)])
  
  renumber(zones)
}

# wrapper around random zones, to ensure group size
random_zones_nmin = function(distances, k, n_min = 2, max_tries = 1e2) {
  try = 1
  while (try < max_tries) {
    z = random_zones(distances, k)
    if (min(table(z)) >= n_min) return(z)
    try = try + 1
  }
  
  NULL
}

deg2rad = function(deg) deg * pi / 180

haversine = function(long1, lat1, long2, lat2, R = 6371) {
  long1 = deg2rad(long1)
  lat1 = deg2rad(lat1)
  long2 = deg2rad(long2)
  lat2 = deg2rad(lat2)
  R * acos(pmin(1.0, sin(lat1) * sin(lat2) + cos(lat1) * cos(lat2) * cos(long2 - long1)))
}

unit_distances = function(unit_data) {
  stopifnot(all(c('unit', 'long', 'lat') %in% names(unit_data)))
  if (any(duplicated(unit_data$unit))) stop('duplicated units')

  units = unit_data$unit
  n_units = length(units)
  
  unit_data %>%
    crossing(., .) %>%
    arrange(unit, unit1) %>%
    mutate(dist = haversine(long, lat, long1, lat1)) %$%
    matrix(dist, ncol = n_units, nrow = n_units) %>%
    set_rownames(units) %>%
    set_colnames(units)
}
```

```{r maup_helper_functions}
aggregate = function(df, group) {
  mutate(df, group = group) %>%
    group_by(group) %>%
    summarize(did = weighted.mean(did, w = population),
              n_resistant = sum(n_resistant),
              n_isolates = sum(n_isolates)) %>%
    mutate(n_susceptible = n_isolates - n_resistant,
           pct_res = n_resistant / n_isolates * 100)
}

group_models = function(df, group) {
  df %>%
    mutate(pct_res = n_resistant / n_isolates * 100) %>%
    split(group) %>%
    map(~ lm(pct_res ~ did, data = .))
}

try_load = function(fn, expr, force_run = FALSE) {
  if (!force_run && file.exists(fn)) {
    read_rds(fn)
  } else {
    value = expr
    write_rds(value, fn)
  }
}
```

```{r marketscan_maup_compute}
# create a hierarchical list: marketscan_maup_data$`Ec/q`$data
marketscan_maup_data = marketscan %>%
  nest(-bugdrug) %>%
  mutate(
    state_id = map(data, ~ match(.$unit, state.name)),
    unit_data = map(data, ~ filter(state_data, unit %in% .$unit)),
    n_units = map_int(unit_data, nrow),
    unit_distances = map(unit_data, unit_distances)
  ) %>%
  gather('key', 'value', -bugdrug) %>%
  nest(key, value, .key = 'value_tbl') %>%
  mutate(value_list = map(value_tbl, ~ setNames(.$value, .$key))) %$%
  setNames(value_list, bugdrug)

maup_group = function(maup_data, k, group_type) {
  switch(group_type,
         'sample' = sample_nmin(maup_data$n_units, k),
         'zone' = random_zones_nmin(maup_data$unit_distances, k),
         'region' = renumber(state.region[maup_data$state_id]),
         'division' = renumber(state.division[maup_data$state_id]),
         'state' = maup_data$state_id,
         'europe_region' = renumber(europe_units$region_name[maup_data[[.y]]$stat_id])
  )
}

n_iterations = 100

marketscan_canonical = crossing(
  bugdrug = marketscan$bugdrug,
  group_type = c('region', 'division', 'state')
)

europe_units = read_tsv('../db/europe_units.tsv') %>%
  select(unit = country, long = longitude, lat = latitude, population, unit_id, region_name)

add_canonical_data = function(df, maup_data) {
  df %>%
    mutate(group = map2(group_type, bugdrug,
                        ~ switch(.x,
                                 'region' = renumber(state.region[maup_data[[.y]]$state_id]),
                                 'division' = renumber(state.division[maup_data[[.y]]$state_id]),
                                 'state' = maup_data[[.y]]$state_id,
                                 'europe_region' = renumber(europe_units$region_name[maup_data[[.y]]$state_id])
                                 )),
           k = map_int(group, ~ length(unique(.))))
}

maup_sim = function(bugdrug, k, n_iterations, canonical_rows, maup_data, fn, force_run = FALSE) {
  try_load(fn, {
    crossing(
      bugdrug = bugdrug,
      k = k,
      group_type = c('sample', 'zone'),
      iteration = 1:n_iterations
    ) %>%
      mutate(group = pmap(list(bugdrug, k, group_type), ~ maup_group(maup_data[[..1]], ..2, ..3))) %>%
      bind_rows(add_canonical_data(canonical_rows, maup_data)) %>%
      mutate(
        group_data = map2(bugdrug, group, ~ aggregate(maup_data[[.x]]$data, .y)),
        group_type = if_else(group_type %in% c('state', 'region', 'division', 'europe_region'), 'canonical', group_type),
        super_model = map(group_data, ~ lm(pct_res ~ did, data = .)),
        super_slope = map_dbl(super_model, ~ coef(.)['did']),
        sub_models = map2(bugdrug, group, ~ group_models(maup_data[[.x]]$data, .y)),
        sub_slopes = map(sub_models, function(ms) map_dbl(ms, ~ coef(.)['did'])),
        median_sub_slope = map_dbl(sub_slopes, ~ median(., na.rm = TRUE)),
        slope_ratio = super_slope / median_sub_slope,
        # weighted linear models
        w_super_model = map(group_data, ~ lm(pct_res ~ did, weights = n_isolates, data = .)),
        w_super_slope = map_dbl(w_super_model, ~ coef(.)['did'])
      )
  }, force_run = force_run)
}

marketscan_maup = maup_sim(
  bugdrug = marketscan$bugdrug,
  k = c(4, 9),
  n_iterations = 100,
  canonical_rows = marketscan_canonical,
  maup_data = marketscan_maup_data,
  fn = 'results/marketscan_maup.rds',
  force_run = FALSE
)
```

### Canonical groupings

```{r marketscan_canonical}
marketscan_canonical_data = marketscan_maup %>%
  filter(group_type == 'canonical') %>%
  mutate(level = case_when(
    .$k == 4 ~ 'region',
    .$k == 9 ~ 'division',
    TRUE ~ 'state'
  )) %>%
  select(bugdrug, level, group_data) %>%
  unnest()
  
marketscan_canonical_data %>%
  ggplot(aes(did, pct_res, color = level)) +
  facet_wrap(~ bugdrug, scales = 'free') +
  geom_smooth(aes(fill = level), method = 'lm', alpha = 0.1) +
  geom_point()

marketscan_canonical_data %>%
  nest(-bugdrug, -level) %>%
  mutate(sd_x = map_dbl(data, ~ sd(.$did)),
         model = map(data, ~ lm(pct_res ~ did, data = .)),
         std_m = map_dbl(model, ~ coef(summary(.))['did', 'Std. Error'])) %>%
  select(bugdrug, level, sd_x, std_m) %>%
  group_by(bugdrug) %>%
  mutate(sd_x_ratio = 1 / (sd_x / tail(sd_x, 1)),
         std_m_ratio = std_m / tail(std_m, 1)) %>%
  kable(caption = 'Variances of x-values and stderr of slope')

marketscan_canonical_data %>%
  nest(-bugdrug) %>%
  mutate(
    var_x = map_dbl(data, ~ var(.$did)),
    base_model = map(data, ~ lm(pct_res ~ did, data = .)),
    base_slope = map_dbl(base_model, ~ coef(.)['did']),
    base_slope_cil = map_dbl(base_model, ~ confint(.)['did', 1]),
    base_slope_ciu = map_dbl(base_model, ~ confint(.)['did', 2]),
    level_model = map(data, ~ lm(pct_res ~ did + did:level, data = .)),
    lr = map2(base_model, level_model, lmtest::lrtest),
    lr_p_value = map_dbl(lr, ~ .$`Pr(>Chisq)`[2])
  ) %>%
  select(bugdrug, base_slope, base_slope_cil, base_slope_ciu, lr_p_value) %>%
  mutate_if(is.numeric, ~ round(., 2)) %>%
  kable(caption = 'Likelihood ratio test, comparing R ~ U and R ~ U + U:level')
```

**swo** clean up

There are some observed resistance values $y_i$ and uses $x_i$ in each state $i$. A linear fit $y_i \sim x_i$ gives the slope $m_1$. A linear fit on the aggregated data gives $m_2$. The null hypothesis is that $m_1 = m_2$, so the test statistic is $m_1 - m_2$. Is the observed value for that statistic consistent with the null hypothesis?

Define $m = \tfrac{1}{2}(m_1 + m_2)$ as an *ad hoc* guess for that underlying parameter, which defines the errors $\varepsilon_i = y_i - m x_i$. The sample population is defined by the distribution of the $\varepsilon_i$. To sample from the population, in each iteration, draw a bootstrap sample $\varepsilon^\star$ from the $\varepsilon$ to compute $y_i^\star = m x_i + \varepsilon_i^\star$. A regression $y_i^\star \sim x_i$ produces a slope $m_1^\star$, which is not necessarily equal to $m$. The regression on the aggregate data produces $m_2^\star$, and thus the sampled test statistic $m_1^\star - m_2^\star$.

```{r}
state_groups = select(state_data, unit, region, division)

adhoc = function(df) {
  df %>%
    left_join(state_groups, by = 'unit') %>%
    mutate(pct_res = 100 * n_resistant / n_isolates)
}

aggregate2 = function(df, group) {
  group_ = enquo(group)
  group_by(df, !!group_) %>%
    summarize(did = weighted.mean(did, w = population),
              n_resistant = sum(n_resistant),
              n_isolates = sum(n_isolates)) %>%
    mutate(n_susceptible = n_isolates - n_resistant,
           pct_res = n_resistant / n_isolates * 100)
}

data_frame(bugdrug = names(marketscan_maup_data)) %>%
  mutate(state_d = map(bugdrug, ~ adhoc(marketscan_maup_data[[.]]$data)),
         state_slope = map_dbl(state_d, ~ coef(lm(pct_res ~ did, data = .))['did']),
         division_data = map(state_d, ~ aggregate2(., division)),
         division_slope = map_dbl(division_data, ~ coef(lm(pct_res ~ did, data = .))['did']),
         region_data = map(state_d, ~ aggregate2(., region)),
         region_slope = map_dbl(region_data, ~ coef(lm(pct_res ~ did, data = .))['did'])
         ) %>%
  identity()

bs_p = function(df1, group, n_iterations = 100) {
  group_ = enquo(group)
  
  df2 = df1 %>% aggregate2(!!group_)
  slope_f = function(df) coef(lm(pct_res ~ did, data = df))['did']
  
  m1 = slope_f(df1)
  m2 = slope_f(df2)
  m = mean(c(m1, m2))
  
  eps = df1$pct_res - m * df1$did
  
  f = function() {
    eps_bs = sample(eps, replace = TRUE)
    y_bs = m * df1$did + eps_bs
    
    m1_bs = coef(lm(y_bs ~ df1$did))[2]
    m2_bs = df1 %>%
      mutate(y_bs = y_bs) %>%
      group_by(!!group_) %>%
      summarize(did = weighted.mean(did, w = population),
                pct_res = weighted.mean(y_bs, w = n_isolates)) %>%
      lm(pct_res ~ did, data = .) %>%
      { coef(.)['did'] }
    
    m1_bs - m2_bs
  }
  
  diffs_bs = replicate(n_iterations, f())
  
  (sum(abs(m1 - m2) < abs(diffs_bs)) + 1) / (n_iterations + 1)
}

data_frame(bugdrug = names(marketscan_maup_data)) %>%
  mutate(state_d = map(bugdrug, ~ adhoc(marketscan_maup_data[[.]]$data)),
         region_p = map_dbl(state_d, ~ bs_p(., region)),
         division_p = map_dbl(state_d, ~ bs_p(., division))) %>%
  select(-state_d) %>%
  kable(caption = 'MarketScan empirical p for different slopes')

data_frame(state_d = list(adhoc(nhsn_maup_data$`Ec/q`$data))) %>%
  mutate(region_p = map_dbl(state_d, ~ bs_p(., region)),
         division_p = map_dbl(state_d, ~ bs_p(., division))) %>%
  select(-state_d) %>%
  kable(caption = 'NHSN')
```

### MAUP

**swo** figure out how to truncate this better

```{r marketscan_maup_plot}
marketscan_maup %>%
  select(bugdrug, k, group_type, super_slope, slope_ratio) %>%
  gather('key', 'value', super_slope, slope_ratio) %>%
  filter(abs(value) < 1000) %>%
  ggplot(aes(factor(k), value, color = group_type)) +
  facet_grid(key ~ bugdrug, scales = 'free') +
  geom_boxplot()

marketscan_maup %>%
  filter(group_type != 'canonical') %>%
  mutate(y = slope_ratio - 1) %>%
  nest(-bugdrug, -group_type, -k) %>%
  mutate(greater_p = map_dbl(data, ~ wilcox.test(.$y, alternative = 'greater')$p.value)) %>%
  select(-data) %>%
  kable(caption = 'Is the slope ratio greater than 1?')
```

```{r marketscan_maup_vals}
bootstrap_ci = function(x, f, R = 1000) {
  if (length(x) == 1) return(c(NA, NA))
  statistic = function(data, idx) f(data[idx])
  boot(data = x, statistic = statistic, R = R) %>%
    boot.ci(type = 'bca') %$%
    bca[c(4, 5)]
}

marketscan_maup %>%
  select(bugdrug, k, group_type, super_slope, median_sub_slope, slope_ratio) %>%
  gather('metric', 'value', super_slope, median_sub_slope, slope_ratio) %>%
  nest(value) %>%
  mutate(values = map(data, ~ .$value),
         median_ = map_dbl(values, median),
         variance = map_dbl(values, var),
         median_ci = map(values, ~ bootstrap_ci(., median)),
         median_lci = map_dbl(median_ci, ~ .[1]),
         median_uci = map_dbl(median_ci, ~ .[2]),
         variance_ci = map(values, ~ bootstrap_ci(., var)),
         variance_lci = map_dbl(variance_ci, ~ .[1]),
         variance_uci = map_dbl(variance_ci, ~ .[2])
  ) %>%
  filter(!(group_type == 'canonical' & metric %in% c('median_sub_slope', 'slope_ratio'))) %>%
  select(metric, bugdrug, group_type, k, median_, median_lci, median_uci, variance, variance_lci, variance_uci) %>%
  mutate_if(is.numeric, ~ round(., 2)) %>%
  arrange(metric, bugdrug, group_type, k) %>%
  kable()
```

## IMS/NHSN CAUTIs

```{r nhsn}
nhsn = read_tsv('../data/nhsn-ims/data.tsv') %>%
  rename(state_abbreviation = state) %>%
  filter(state_abbreviation %in% state.abb) %>%
  mutate(state_id = match(state_abbreviation, state.abb),
         unit = state.name[state_id],
         bugdrug = 'Ec/q',
         did = us_europe_convert('quinolone', rx_1k_year)) %>%
  arrange(unit) %>%
  left_join(select(state_data, unit, population), by = 'unit') %>%
  select(unit, bugdrug, did, n_resistant, n_isolates, population)

nhsn_maup_data = nhsn %>%
  nest(-bugdrug) %>%
  mutate(
    state_id = map(data, ~ match(.$unit, state.name)),
    unit_data = map(data, ~ filter(state_data, unit %in% .$unit)),
    n_units = map_int(unit_data, nrow),
    unit_distances = map(unit_data, unit_distances)
  ) %>%
  gather('key', 'value', -bugdrug) %>%
  nest(key, value, .key = 'value_tbl') %>%
  mutate(value_list = map(value_tbl, ~ setNames(.$value, .$key))) %$%
  setNames(value_list, bugdrug)

nhsn_canonical = crossing(
  bugdrug = 'Ec/q',
  group_type = c('region', 'division', 'state')
)

nhsn_maup = maup_sim(
  bugdrug = 'Ec/q',
  k = c(4, 9),
  n_iterations = 100,
  canonical_rows = nhsn_canonical,
  maup_data = nhsn_maup_data,
  fn = 'results/nhsn_maup.rds',
  force_run = FALSE
)
```

### Canonical groupings

```{r nhsn_canonical}
nhsn_maup %>%
  filter(group_type == 'canonical') %>%
  mutate(level = case_when(
    .$k == 4 ~ 'region',
    .$k == 9 ~ 'division',
    TRUE ~ 'state'
  )) %>%
  select(bugdrug, level, group_data) %>%
  unnest() %>%
  ggplot(aes(did, pct_res, color = level)) +
  facet_wrap(~ bugdrug, scales = 'free') +
  geom_smooth(aes(fill = level), method = 'lm', alpha = 0.1) +
  geom_point()

nhsn_maup %>%
  filter(group_type == 'canonical') %>%
  mutate(level = case_when(
    .$k == 4 ~ 'region',
    .$k == 9 ~ 'division',
    TRUE ~ 'state'
  )) %>%
  mutate(model = map(group_data, ~ lm(pct_res ~ did, data = .)),
         slope = map_dbl(model, ~ coef(.)['did']),
         lci = map_dbl(model, ~ confint(.)['did', 1]),
         uci = map_dbl(model, ~ confint(.)['did', 2])) %>%
  select(bugdrug, level, slope, lci, uci)
```

### MAUP

**swo** refactor this in the same style as marketscan. also combine it with Europe at the same time?

```{r nhsn_maup_plot}
nhsn_maup %>%
  ggplot(aes(factor(k), super_slope, color = group_type)) +
  facet_wrap(~ bugdrug, scales = 'free') +
  geom_boxplot()

nhsn_maup %>%
  select(bugdrug, k, group_type, slope_ratio) %>%
  filter(is.finite(slope_ratio)) %>%
  ggplot(aes(factor(k), slope_ratio, color = group_type)) +
  geom_hline(yintercept = 1) +
  geom_boxplot() +
  ylim(-10, 10)

nhsn_maup %>%
  filter(group_type != 'canonical') %>%
  mutate(y = slope_ratio - 1) %>%
  nest(-bugdrug, -group_type, -k) %>%
  mutate(greater_p = map_dbl(data, ~ wilcox.test(.$y, alternative = 'greater')$p.value)) %>%
  select(-data) %>%
  kable()
```

```{r nhsn_numbers}
nhsn_maup %>%
  select(k, group_type, super_slope, median_sub_slope, slope_ratio) %>%
  gather('metric', 'value', super_slope, median_sub_slope, slope_ratio) %>%
  nest(value) %>%
  mutate(values = map(data, ~ .$value),
         median_ = map_dbl(values, median),
         variance = map_dbl(values, var),
         median_ci = map(values, ~ bootstrap_ci(., median)),
         median_lci = map_dbl(median_ci, ~ .[1]),
         median_uci = map_dbl(median_ci, ~ .[2]),
         variance_ci = map(values, ~ bootstrap_ci(., var)),
         variance_lci = map_dbl(variance_ci, ~ .[1]),
         variance_uci = map_dbl(variance_ci, ~ .[2])
  ) %>%
  filter(!(group_type == 'canonical' & metric %in% c('median_sub_slope', 'slope_ratio'))) %>%
  select(metric, group_type, k, median_, median_lci, median_uci, variance, variance_lci, variance_uci) %>%
  mutate_if(is.numeric, ~ round(., 2)) %>%
  arrange(metric, group_type, k) %>%
  kable()
```

## Europe

```{r europe_data}
europe = read_tsv('../data/ecdc/data.tsv') %>%
  mutate(bugdrug = case_when(
    .$bug == 'Escherichia coli' & .$drug == 'quinolone' ~ 'Ec/q',
    .$bug == 'Streptococcus pneumoniae' & .$drug == 'beta_lactam' ~ 'Sp/bl',
    .$bug == 'Streptococcus pneumoniae' & .$drug == 'macrolide' ~ 'Sp/m'
  )) %>%
  rename(unit = country) %>%
  left_join(select(europe_units, unit, population), by = 'unit') %>%
  select(unit, bugdrug, did, n_resistant = n_ns, n_isolates, population)

europe_names = unique(europe$unit)

europe_maup_data = europe %>%
  nest(-bugdrug) %>%
  mutate(
    state_id = map(data, ~ match(.$unit, europe_names)),
    unit_data = map(data, ~ filter(europe_units, unit %in% .$unit)),
    n_units = map_int(unit_data, nrow),
    unit_distances = map(unit_data, unit_distances)
  ) %>%
  gather('key', 'value', -bugdrug) %>%
  nest(key, value, .key = 'value_tbl') %>%
  mutate(value_list = map(value_tbl, ~ setNames(.$value, .$key))) %$%
  setNames(value_list, bugdrug)

# swo: come up with a better name than "state"
europe_canonical = crossing(
  bugdrug = europe$bugdrug,
  group_type = c('state', 'europe_region')
)

europe_maup = maup_sim(
  bugdrug = unique(europe$bugdrug),
  k = c(4),
  n_iterations = 100,
  canonical_rows = europe_canonical,
  maup_data = europe_maup_data,
  fn = 'results/europe_maup.rds',
  force_run = FALSE
)
```

### Canonical

```{r europe_canonical}
europe_maup %>%
  filter(group_type == 'canonical') %>%
  mutate(level = case_when(
    .$k == 4 ~ 'region',
    .$k == 9 ~ 'division',
    TRUE ~ 'state'
  )) %>%
  select(bugdrug, level, group_data) %>%
  unnest() %>%
  ggplot(aes(did, pct_res, color = level)) +
  facet_wrap(~ bugdrug, scales = 'free') +
  geom_smooth(aes(fill = level), method = 'lm', alpha = 0.1) +
  geom_point()
```

### MAUP

```{r europe_maup_plot}
europe_maup %>%
  ggplot(aes(factor(k), super_slope, color = group_type)) +
  facet_wrap(~ bugdrug, scales = 'free') +
  geom_boxplot()

europe_maup %>%
  select(bugdrug, k, group_type, slope_ratio) %>%
  filter(is.finite(slope_ratio)) %>%
  ggplot(aes(factor(k), slope_ratio, color = group_type)) +
  facet_wrap(~ bugdrug) +
  geom_hline(yintercept = 1) +
  geom_boxplot()

europe_maup %>%
  filter(group_type != 'canonical') %>%
  mutate(y = slope_ratio - 1) %>%
  nest(-bugdrug, -group_type, -k) %>%
  mutate(greater_p = map_dbl(data, ~ wilcox.test(.$y, alternative = 'greater')$p.value)) %>%
  select(-data) %>%
  kable()
```

```{r europe_numbers}
europe_maup %>%
  select(bugdrug, k, group_type, super_slope, median_sub_slope, slope_ratio) %>%
  gather('metric', 'value', super_slope, median_sub_slope, slope_ratio) %>%
  nest(value) %>%
  mutate(values = map(data, ~ .$value),
         median_ = map_dbl(values, median),
         variance = map_dbl(values, var),
         median_ci = map(values, ~ bootstrap_ci(., median)),
         median_lci = map_dbl(median_ci, ~ .[1]),
         median_uci = map_dbl(median_ci, ~ .[2]),
         variance_ci = map(values, ~ bootstrap_ci(., var)),
         variance_lci = map_dbl(variance_ci, ~ .[1]),
         variance_uci = map_dbl(variance_ci, ~ .[2])
  ) %>%
  filter(!(group_type == 'canonical' & metric %in% c('median_sub_slope', 'slope_ratio'))) %>%
  select(metric, bugdrug, group_type, k, median_, median_lci, median_uci, variance, variance_lci, variance_uci) %>%
  mutate_if(is.numeric, ~ round(., 2)) %>%
  arrange(metric, bugdrug, group_type, k) %>%
  kable()
```

## Distance analysis

If local tranmission "washes out" the use/resistance relationship, then we expect that pairs of states that are closer to one another will have a greater difference in resistance for the same difference in use. That is:
$$
\Delta \rho \sim \Delta \tau + \Delta \tau \times d
$$
We expect that $\beta_{\tau d} > 1$, meaning that greater distances $d$ give you a bonus in $\Delta \rho$ for that same $\Delta \tau$:
$$
\Delta \rho_i = \beta_\tau \Delta \tau + \beta_{\tau d} \Delta \tau \times d = (\beta_\tau + \beta_{\tau d} d) \Delta \tau.
$$

```{r}
f = function(bd, n_iter = 1e3) {
  d = bd$data %>%
    mutate(pct_res = 100 * n_resistant / n_isolates,
           i = 1:n()) %>%
    select(unit, i, did, pct_res)
  
  units = unique(d$unit)
  x = crossing(unit1 = units, unit2 = units) %>%
    filter(unit1 < unit2) %>%
    left_join(d, by = c('unit1' = 'unit')) %>%
    left_join(d, by = c('unit2' = 'unit'), suffix = c('1', '2')) %>%
    mutate(dist = map2_dbl(i1, i2, ~ bd$unit_distances[.x, .y]),
           dr = pct_res2 - pct_res1,
           du = did2 - did1)
  
  # is there an interaction dr ~ du x dist?
  obs_model = lm(dr ~ du + du:dist, data = x)
  obs_interaction = coef(obs_model)['du:dist']
  obs_slope = coef(obs_model)['du']
  obs_ratio = obs_interaction / obs_slope
  
  # permutation test for that
  permuted_model = function() {
    id_map = sample(unique(x$i1))
    permute_m = x %>%
      mutate(
        permuted_i1 = id_map[i1],
        permuted_i2 = id_map[i2],
        permuted_dist = map2_dbl(permuted_i1, permuted_i2, ~ bd$unit_distances[.x, .y])
      ) %>%
      lm(dr ~ du + du:permuted_dist, data = .)
  }

  permuted_models = rerun(n_iter, permuted_model())
  
  permuted_interactions = map_dbl(permuted_models, ~ coef(.)['du:permuted_dist'])
  permuted_slopes = map_dbl(permuted_models, ~ coef(.)['du'])
  permuted_ratios = permuted_interactions / permuted_slopes
  r = sum(abs(obs_ratio) < abs(permuted_ratios))
  p = (r + 1) / (n_iter + 1)
  
  list(
    obs_model = obs_model,
    obs_ratio = obs_ratio,
    permuted_models = permuted_models,
    permuted_ratios = permuted_ratios,
    p = p
  )
}

g = function(dataset, lst) {
  data_frame(
    dataset = dataset,
    bugdrug = names(lst),
    results = map(lst, f),
    bdt = map_dbl(results, ~ .$obs_ratio),
    p = map_dbl(results, ~ .$p)
  )
}

res = bind_rows(
  g('marketscan', marketscan_maup_data),
  g('nhsn', nhsn_maup_data),
  g('europe', europe_maup_data)
)

res %>%
  mutate(sig = p.adjust(p, 'BH') < 0.05) %>%
  select(-results) %>%
  kable(caption = 'Observed results, and stat tests')
```

```{r}
# Bootstrapping CIs on the slope/interaction ratios
f = function(bd, n_iter = 1e3) {
  d = bd$data %>%
    mutate(pct_res = 100 * n_resistant / n_isolates,
           i = 1:n()) %>%
    select(unit, i, did, pct_res)
  
  units = unique(d$unit)
  
  bs = boot::boot(units, statistic = function(data, idx) {
    crossing(unit1 = data[idx], unit2 = data[idx]) %>%
      filter(unit1 < unit2) %>%
      left_join(d, by = c('unit1' = 'unit')) %>%
      left_join(d, by = c('unit2' = 'unit'), suffix = c('1', '2')) %>%
      mutate(dist = map2_dbl(i1, i2, ~ bd$unit_distances[.x, .y]),
             dr = pct_res2 - pct_res1,
             du = did2 - did1) %>%
      lm(dr ~ du + du:dist, data = .) %>%
      coef() %>%
      { .['du:dist'] / .['du'] }
  }, R = n_iter)
  
  bs_ci = boot::boot.ci(bs, type = 'bca') %$%
    bca[c(4, 5)]
  
  list(
    obs_ratio = bs$t0,
    bs_lci = bs_ci[1],
    bs_uci = bs_ci[2]
  )
}

f(marketscan_maup_data$`Ec/q`)

g = function(dataset, lst) {
  data_frame(
    dataset = dataset,
    bugdrug = names(lst),
    results = map(lst, f),
    bdt = map_dbl(results, ~ .$obs_ratio),
    lci = map_dbl(results, ~ .$bs_lci),
    uci = map_dbl(results, ~ .$bs_uci)
  )
}

bs_res = bind_rows(
  g('marketscan', marketscan_maup_data),
  g('nhsn', nhsn_maup_data),
  g('europe', europe_maup_data)
)

bs_res %>%
  select(-results) %>%
  kable()
```

```{r}
# Bootstrapping logistic CIs
f = function(bd, n_iter = 1e2) {
  d = bd$data %>%
    mutate(i = 1:n()) %>%
    select(unit, i, did, n_resistant, n_isolates)
  
  units = unique(d$unit)
  
  bs = boot::boot(units, statistic = function(data, idx) {
    crossing(unit1 = data[idx], unit2 = data[idx]) %>%
      filter(unit1 < unit2) %>%
      left_join(d, by = c('unit1' = 'unit')) %>%
      left_join(d, by = c('unit2' = 'unit'), suffix = c('1', '2')) %>%
      mutate(dist = map2_dbl(i1, i2, ~ bd$unit_distances[.x, .y]),
             dr = pct_res2 - pct_res1,
             du = did2 - did1) %>%
      glm(n_resistant ~ du + du:dist, family = 'binomial', weights = n_isolates, data = .) %>%
      coef() %>%
      { .['du:dist'] / .['du'] }
  }, R = n_iter)
  
  bs_ci = boot::boot.ci(bs, type = 'bca') %$%
    bca[c(4, 5)]
  
  list(
    obs_ratio = bs$t0,
    bs_lci = bs_ci[1],
    bs_uci = bs_ci[2]
  )
}

f(marketscan_maup_data$`Ec/q`)

g = function(dataset, lst) {
  data_frame(
    dataset = dataset,
    bugdrug = names(lst),
    results = map(lst, f),
    bdt = map_dbl(results, ~ .$obs_ratio),
    lci = map_dbl(results, ~ .$bs_lci),
    uci = map_dbl(results, ~ .$bs_uci)
  )
}

bs_res = bind_rows(
  g('marketscan', marketscan_maup_data),
  g('nhsn', nhsn_maup_data),
  g('europe', europe_maup_data)
)

bs_res %>%
  select(-results) %>%
  kable()
```

All the point estimates are positive, and some $p$-values are below $0.05$, but none pass an FDR $Q < 0.05$. Interestingly, the point estimates are fairly similar, in the range of $10^{-3}$ or below.

These results suggest that $\beta_{\tau d}$ is of order $10^{-3}$, measured in slope units (percentage points per DID) per kilometer. The distance between the US coasts is about 4,000 kilometers, so a large distance $d$ between states is on the order of 1,000 kilometers, and a large effect would be $\beta_{\tau d} d \approx 1$ percentage points per DID.

Strong slopes are 5-10, so getting a huge geographic range gives you an order of 10% bonus. Could be 50%, but it's not 10-fold.
