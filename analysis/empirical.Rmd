---
title: "Empirical use-resistance relationships over geographic scales"
author: "Scott Olesen"
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 4, fig.path = 'fig/',
  dev = c('png', 'pdf'),
  echo = FALSE, warning = FALSE, message = FALSE,
  cache = TRUE, autodep = TRUE)

pdf.options(useDingbats = FALSE, useKerning = FALSE)

library(MASS)
map = purrr::map
select = dplyr::select
```

# Methods

## Use and resistance data

### MarketScan

```{r maup_db}
state_data = read_tsv('../db/state_data.tsv') %>%
  rename(us_region = region, us_division = division) %>%
  mutate(density = population / area)
```

```{r marketscan_data}
marketscan_res = read_tsv('~/grad/proj/medicare/analysis/ms2/data/abg_state.tsv', col_types = cols('n_isolates' = 'n')) %>%
  # specify n_isolates as "n" to parse things like "5e3"
  mutate_at('n_isolates', as.integer) %>%
  rename(drug = drug_group) %>%
  mutate(bugdrug = case_when(
    .$bug == 'E. coli' & .$drug == 'quinolone' ~ 'Ec/q',
    .$bug == 'S. pneumoniae' & .$drug == 'beta_lactam' ~ 'Sp/bl',
    .$bug == 'S. pneumoniae' & .$drug == 'macrolide' ~ 'Sp/m'
  )) %>%
  filter(!is.na(bugdrug)) %>%
  mutate(n_resistant = as.integer(round(f_ns * n_isolates))) %>%
  select(bugdrug, drug, state, n_resistant, n_isolates)

marketscan_use = read_tsv('~/grad/proj/medicare/analysis/ms2/ineq_marketscan.tsv') %>%
  rename(drug = drug_group, use = total_use) %>%
  filter(drug %in% c('quinolone', 'beta_lactam', 'macrolide'))

marketscan = marketscan_use %>%
  inner_join(marketscan_res, by = c('drug', 'state')) %>%
  rename(unit = state) %>%
  left_join(state_data, by = 'unit') %>%
  select(
    unit, bugdrug, use, n_resistant, n_isolates,
    population, density, income, temperature,
    us_region, us_division
  )
```

### NHSN/IMS

```{r nhsn_ims}
nhsn = read_tsv('../data/nhsn-ims/data.tsv') %>%
  rename(state_abbreviation = state) %>%
  filter(state_abbreviation %in% state.abb) %>%
  mutate(
    unit_id = match(state_abbreviation, state.abb),
    bugdrug = 'Ec/q',
    use = rx_1k_year / 1e3
  ) %>%
  left_join(state_data, by = 'unit_id') %>%
  select(
    unit, bugdrug, use, n_resistant, n_isolates,
    population, density, income, temperature,
    us_region, us_division
  )
```

### ECDC

For the European data, we convert to "treatments" per person per year, assuming a certain conversion from DDD to treatments. This is just an *ad hoc* adjustment to get the European data to the same scales as used in the simulations and the US data.

```{r ecdc_convert}
did_cpy_map = data_frame(
  drug = c('beta_lactam', 'quinolone', 'macrolide'),
  ddd_per_tx = c(10, 10, 7),
  cpy_per_did = 365 / (1e3 * ddd_per_tx)
)

did_cpy_map %>%
  kable(caption = 'DDD to treatment conversion')
```

```{r ecdc}
europe_units = read_tsv('../db/europe_units.tsv') %>%
  mutate(density = population / area) %>%
  select(unit_id, unit, population, eu_region = region, density, income, temperature)

europe = read_tsv('../data/ecdc/data.tsv') %>%
  left_join(did_cpy_map, by = 'drug') %>%
  mutate(use = cpy_per_did * did) %>%
  mutate(bugdrug = case_when(
    .$bug == 'Escherichia coli' & .$drug == 'quinolone' ~ 'Ec/q',
    .$bug == 'Streptococcus pneumoniae' & .$drug == 'beta_lactam' ~ 'Sp/bl',
    .$bug == 'Streptococcus pneumoniae' & .$drug == 'macrolide' ~ 'Sp/m'
  )) %>%
  rename(unit = country) %>%
  left_join(europe_units, by = 'unit') %>%
  select(
    unit, bugdrug, use, n_resistant = n_ns, n_isolates,
    population, density, temperature, income,
    eu_region
  )

europe_names = unique(europe$unit)
```

```{r combine_data}
named_bind_rows = function(..., label = 'dataset') {
  names = map_chr(quos(...), quo_name)
  map2_dfr(list(...), names, ~ mutate(.x, !!as.symbol(label) := .y))
}

unit_data = named_bind_rows(marketscan, nhsn, europe) %>%
  mutate(
    n_susceptible = n_isolates - n_resistant,
    f_resistant = n_resistant / n_isolates
  )

# look for dataset/region combinations to do
region_combinations = unit_data %>%
  group_by(dataset, bugdrug) %>%
  summarize_at(c('unit', 'us_region', 'us_division', 'eu_region'), ~ not(any(is.na(.)))) %>%
  ungroup() %>%
  gather('group_type', 'is_present', -dataset, -bugdrug) %>%
  filter(is_present) %>% select(-is_present) %>%
  arrange(dataset, bugdrug, group_type)
```

## Adjacency

```{r adjacency_db}
us_adjacency = read_tsv('../db/state_adjacency.tsv')
eu_adjacency = read_tsv('../db/europe_adjacency.tsv')
```

# Results

## Regional analysis

Aggregate the data into regions: Census regions and divisions for US data, and UN Geoscheme regions for European data. Aggregate use data by population-weighted means. Aggregate resistance data by adding up the numbers of susceptible and resistant isolates.

```{r region_data}
aggregate_at = function(df, group_chr) {
  stopifnot(class(group_chr) == 'character')
  group = as.symbol(group_chr)
  
  group_by_at(df, group_chr, .add = TRUE) %>%
    summarize(
      use = weighted.mean(use, w = population),
      n_resistant = sum(n_resistant),
      n_isolates = sum(n_isolates)
    ) %>%
    ungroup() %>%
    rename(group := !!group) %>%
    mutate(
      group_type = group_chr,
      n_susceptible = n_isolates - n_resistant
    )
}

region_data = region_combinations %>%
  mutate(
    unit_data = map2(dataset, bugdrug, ~ filter(unit_data, dataset == .x, bugdrug == .y)),
    region_data = map2(unit_data, group_type, aggregate_at)
  )
```

Run logistic regressions predicting resistance from use rates for each dataset, bug/drug, and group type. Group types include baseline "units" (US states or European countries), US Census regions, etc. Get a $p$-value on whether the slopes in the aggregates are different than the ones in the baseline units by shuffling the region labels.

```{r regional_analysis}
model_f = function(df) {
  glm(
    cbind(n_resistant, n_susceptible) ~ use,
    family = 'binomial', data = df
  )
}

pred_data_f = function(data, model) {
  # x-values to make the predictions on
  pred_use = seq(
    from = min(data$use), to = max(data$use),
    length.out = 100
  )
  
  # prediction object
  pred = predict(
    model, newdata = data_frame(use = pred_use),
    type = 'response', se.fit = TRUE
  )
  
  # prediction "data" points
  data_frame(
    use = pred_use,
    res = pred$fit,
    ymax = pred$fit + 1.96 * pred$se.fit,
    ymin = pred$fit - 1.96 * pred$se.fit
  )
}

# do p-value calculations
null_slopes_f = function(df, group_chr, n_trials = 999) {
  if(group_chr == 'unit') return(NA)
  
  map_dbl(1:n_trials, function(i) {
    df %>%
      # shuffle the group variable values
      mutate_at(group_chr, sample) %>%
      aggregate_at(group_chr) %>%
      model_f() %>%
      { coef(.)['use'] }
  })
}

region_models = region_data %>%
  mutate(
    # fit models to each dataset, bugdrug, & aggregate type
    model = map(region_data, model_f),
    # extract "slope" and CIs around that value
    slope = map_dbl(model, ~ coef(.)['use']),
    ci = map(model, confint.default),
    slope_cil = map_dbl(ci, ~ .['use', 1]),
    slope_ciu = map_dbl(ci, ~ .['use', 2]),
    # get data needed to plot the 95% CI fit line
    pred_data = map2(region_data, model, pred_data_f),
    # get range of null slopes
    null_slopes = map2(unit_data, group_type, null_slopes_f)
  ) %>%
  # the "base" slopes are the cross-unit measurements
  group_by(dataset, bugdrug) %>%
  mutate(base_slope = slope[group_type == 'unit']) %>%
  ungroup() %>%
  # p-values are empirical, looking at null slopes
  mutate(p_value = map2_dbl(null_slopes, base_slope, ~ (sum(.x > .y) + 1) / (length(.x) + 1))) %>%
  arrange(dataset, bugdrug, group_type)
```

```{r regional_results_table}
region_models %>%
  mutate(
    dataset = recode(dataset, 'europe' = 'ECDC', 'marketscan' = 'MarketScan/RO', 'nhsn' = 'IMS/NHSN'),
    group_type = factor(group_type, levels = c('unit', 'us_division', 'us_region', 'eu_region')),
    slope = sprintf('%.2f (%.2f to %.2f)', slope, slope_cil, slope_ciu)
  ) %>%
  select(dataset, bugdrug, group_type, slope, p_value) %>%
  arrange(dataset, bugdrug, group_type) %>%
  kable()
```

### Plots

```{r regional_results_plot}
plotify_region_data = function(df) {
  df %>%
    mutate(
      dataset = recode(dataset, 'europe' = 'ECDC', 'marketscan' = 'MarketScan/RO', 'nhsn' = 'IMS/NHSN'),
      long_bugdrug = recode(bugdrug, 'Ec/q' = 'E. coli & quinolones', 'Sp/m' = 'S. pneumonia & macrolides', 'Sp/bl' = 'S. pneumoniae & beta-lactams'),
      label = str_c(dataset, ' ', bugdrug),
      group_fct = factor(case_when(
        group_type == 'unit' ~ 'unit',
        group_type == 'us_division' ~ 'division',
        group_type %in% c('us_region', 'eu_region') ~ 'region',
        TRUE ~ NA_character_
      ), levels = c('unit', 'division', 'region'))
    )
}

# pull out the data and the predictions separately
region_plot_data = region_models %>%
  select(dataset, bugdrug, group_type, region_data) %>%
  unnest() %>%
  mutate(res = n_resistant / n_isolates) %>%
  plotify_region_data()

region_pred_data = region_models %>%
  select(dataset, bugdrug, group_type, pred_data) %>%
  unnest() %>%
  plotify_region_data()

# and just the marketscan data, for the main text figure
marketscan_region_plot_data = region_plot_data %>%
  filter(dataset == 'MarketScan/RO')

marketscan_region_pred_data = region_pred_data %>%
  filter(dataset == 'MarketScan/RO')

# and the other stuff
other_region_plot_data = region_plot_data %>%
  filter(dataset != 'MarketScan/RO')

other_region_pred_data = region_pred_data %>%
  filter(dataset != 'MarketScan/RO')

marketscan_regional_plot = ggplot(data = NULL, aes(use, res)) +
  facet_wrap(~ long_bugdrug, scales = 'free') +
  geom_ribbon(
    data = marketscan_region_pred_data,
    aes(ymin = ymin, ymax = ymax, fill = group_fct),
    color = NA, alpha = 0.25
  ) +
  scale_fill_manual(values = rep('black', 3)) +
  geom_point(data = marketscan_region_plot_data, aes(shape = group_fct)) +
  # unit = open circle, division = open triangle, region = filled circle
  scale_shape_manual(values = c(1, 2, 16)) +
  geom_line(data = marketscan_region_pred_data, aes(linetype = group_fct)) +
  # unit = solid line, division = dotted, region = dashed
  scale_linetype_manual(values = c(1, 3, 5)) +
  xlab('antibiotic use (annual treatments per capita)') +
  scale_y_continuous(
    'antibiotic resistance (% of isolates)',
    labels = scales::percent_format(accuracy = 1, suffix = '')
  ) +
  theme_classic() +
  theme(
    legend.position = 'none',
    strip.text = element_text(size = 8),
    strip.background = element_blank(),
    axis.text = element_text(size = 8, color = 'black'),
    axis.title = element_text(size = 8)
  )

show(marketscan_regional_plot)

other_regional_plot = ggplot(data = NULL, aes(use, res)) +
  facet_wrap(~ label, scales = 'free') +
  geom_ribbon(data = other_region_pred_data, aes(ymin = ymin, ymax = ymax, fill = group_fct), color = NA, alpha = 0.25) +
  scale_fill_manual(values = rep('black', 3)) +
  geom_point(data = other_region_plot_data, aes(shape = group_fct)) +
  # unit = open circle, division = open triangle, region = filled circle
  scale_shape_manual(values = c(1, 2, 16)) +
  geom_line(data = other_region_pred_data, aes(linetype = group_fct)) +
  # unit = solid line, division = dotted, region = dashed
  scale_linetype_manual(values = c(1, 3, 5)) +
  xlab('antibiotic use (annual treatments per capita)') +
  scale_y_continuous(
    'antibiotic resistance (% of isolates)',
    labels = scales::percent_format(accuracy = 1, suffix = '')
  ) +
  theme_classic() +
  theme(
    legend.position = 'none',
    strip.text = element_text(size = 8),
    strip.background = element_blank(),
    axis.text = element_text(size = 8, color = 'black'),
    axis.title = element_text(size = 8)
  )

show(other_regional_plot)

ggsave(
  'fig/marketscan_regional.pdf',
  plot = marketscan_regional_plot,
  width = 180, height = 80, units = 'mm'
)

ggsave(
  'fig/other_regional.pdf',
  plot = other_regional_plot,
  width = 180, height = 120, units = 'mm'
)
```

## Distance analysis

If local transmission "washes out" the use/resistance relationship, then we expect that adjacent geographic units will have a *smaller* difference in resistance for the same difference in use. (Consider the extreme: two perfectly-interacting populations should have almost no difference in resistance, regardless of their difference in use.) That is, in a regression
$$
\Delta \rho \sim \Delta \tau + \Delta \tau \times a + \Delta \mathrm{income} + \ldots
$$
where $a$ is a flag for adjacency, we expect the interaction term $\beta_{\tau a}$ will be negative.

```{r distance_analysis}
# because no US states and European countries share names, it's OK to combine this list
adjacency_db = bind_rows(us_adjacency, eu_adjacency) %>%
  mutate(adjacent = 1)

odds = function(p) p / (1 - p)
log_odds_ratio = function(p, q) log(odds(p)) - log(odds(q))

cross_units = function(df) {
  df %$%
    crossing(unit1 = unit, unit2 = unit) %>%
    left_join(rename_all(df, ~ str_c(., '1')), by = 'unit1') %>%
    left_join(rename_all(df, ~ str_c(., '2')), by = 'unit2') %>%
    filter(use1 > use2) %>%
    mutate(
      d_resistant = f_resistant1 - f_resistant2,
      d_use = log_odds_ratio(use1, use2),
      d_income = income1 - income2,
      d_density = density1 - density2,
      d_temperature = temperature1 - temperature2
    ) %>%
    select(unit1, unit2, starts_with('d_')) %>%
    left_join(adjacency_db, by = c('unit1', 'unit2')) %>%
    # pairs of units not in the adjacency list are not adjacent
    replace_na(list(adjacent = 0))
}

# shuffle the use/resistance values, keeping adjacency, income, etc.
shuffle_useres = function(df) {
  new_order = sample(nrow(df))
  df %>%
    mutate_at(c('f_resistant', 'use'), ~ .[new_order])
}

bisquare = partial(MASS::rlm, psi = MASS::psi.bisquare)
pair_model_f = function(df) {
  bisquare(d_resistant ~ d_use + d_use:adjacent + d_income + d_density + d_temperature, data = df)
}

null_interactions_f = function(df, n_trials = 999) {
  replicate(n_trials, {
    df %>%
      shuffle_useres %>%
      cross_units %>%
      pair_model_f %>%
      { unname(coef(.)['d_use:adjacent']) }
  })
}

confint.rlm = function(m) {
  cs = coef(summary(m))
  estimate = cs[, 'Value']
  se = cs[, 'Std. Error']

  cbind(estimate - 1.96 * se, estimate + 1.96 * se) %>%
    set_rownames(names(estimate)) %>%
    set_colnames(c('2.5%', '97.5%'))
}

distance_results = unit_data %>%
  nest(-dataset, -bugdrug) %>%
  mutate(
    pair_data = map(data, cross_units),
    model = map(pair_data, pair_model_f),
    coef_d_use = map_dbl(model, ~ coef(.)['d_use']),
    coef_d_use_adjacent = map_dbl(model, ~ coef(.)['d_use:adjacent']),
    coef_ratio = coef_d_use_adjacent / coef_d_use,
    ci = map(model, confint.rlm),
    dua_cil = map_dbl(ci, ~ .['d_use:adjacent', 1]),
    dua_ciu = map_dbl(ci, ~ .['d_use:adjacent', 2]),
    null_interactions = map(data, null_interactions_f),
    # the inequality is <, because actual is -1 and nulls are all around 0, we get strong (0) p value
    p_value = map2_dbl(null_interactions, coef_d_use_adjacent, ~ (sum(.x < .y) + 1) / (length(.x) + 1))
  )
```

```{r distance_results_table}
distance_results %>%
  mutate(
    dataset = recode(dataset, 'europe' = 'ECDC', 'marketscan' = 'MarketScan/RO', 'nhsn' = 'IMS/NHSN'),
    interaction = sprintf('%.2f (%.2f to %.2f)', coef_d_use_adjacent, dua_cil, dua_ciu)
  ) %>%
  mutate(sig = p.adjust(p_value, 'BH') < 0.05) %>%
  select(dataset, bugdrug, interaction, p_value, sig) %>%
  arrange(dataset, bugdrug) %>%
  kable()
```

### Plots

First plot shows MS/RO and Sp/m.

```{r distance_plots}
main_distance_plot = distance_results %>%
  filter(dataset == 'marketscan', bugdrug == 'Sp/m') %$%
  pair_data[[1]] %>%
  mutate(adjacent = adjacent == 1) %>%
  ggplot(aes(d_use, d_resistant, color = adjacent)) +
  geom_point(shape = 1) +
  stat_smooth(method = 'rlm') +
  scale_color_manual(values = c('black', 'red')) +
  xlab('Difference in antibiotic use (annual treatments per capita)') +
  ylab('Difference in resistance (log odds ratio)') +
  theme_classic() +
  theme(
    legend.position = 'none',
    axis.text = element_text(size = 8, color = 'black'),
    axis.title = element_text(size = 8)
  )

show(main_distance_plot)

other_distance_plot = distance_results %>%
  filter(!(dataset == 'marketscan' & bugdrug == 'Sp/m')) %>%
  select(dataset, bugdrug, pair_data) %>%
  unnest() %>%
  mutate(
    adjacent = adjacent == 1,
    dataset = recode(dataset, 'europe' = 'ECDC', 'marketscan' = 'MarketScan/RO', 'nhsn' = 'IMS/NHSN'),
    label = str_c(dataset, ' ', bugdrug)
  ) %>%
  ggplot(aes(d_use, d_resistant, color = adjacent)) +
  facet_wrap(~ label, scales = 'free') +
  geom_point(shape = 1, size = 0.5) +
  stat_smooth(method = 'rlm') +
  scale_color_manual(values = c('black', 'red')) +
  xlab('Difference in antibiotic use (annual treatments per capita)') +
  ylab('Difference in resistance (log odds ratio)') +
  theme_classic() +
  theme(
    legend.position = 'none',
    strip.text = element_text(size = 8),
    strip.background = element_blank(),
    axis.text = element_text(size = 8, color = 'black'),
    axis.title = element_text(size = 8)
  )

show(other_distance_plot)

ggsave(
  'fig/main_distance_plot.pdf',
  plot = main_distance_plot,
  width = 88, height = 80, units = 'mm'
)

ggsave(
  'fig/other_distance_plot.pdf',
  plot = other_distance_plot,
  width = 180, height = 80, units = 'mm'
)
```

# Discussion

```{r concept}
exp_f = function(x0, b) {
  function(x) 1 - exp(-(x - x0) / b)
}

logistic_f = function(x0, b) {
  function(x) 1 / (1 + exp(-(x - x0) / b))
}

line1 = exp_f(-1, 0.2)
line2 = logistic_f(-0.2, 0.2)
line3 = logistic_f(0.5, 0.2)

known = data_frame(
  x = c(-1, 1, 1.5),
  y = c(0, 1, 1),
  level = c('individual', 'state', 'region')
)

daycare_x = -0.4
guess = data_frame(
  x = c(daycare_x, 0.5),
  y = c(line1(daycare_x), line2(0.5)),
  level = c('daycare', 'city')
)

concept_plot = ggplot(known, aes(x, y)) +
  geom_point(shape = 16, size = 3) +
  geom_point(data = guess, shape = 1, size = 3) +
  geom_segment(data = guess, aes(xend = x, yend = -0.1), linetype = 3) +
  stat_function(fun = line1, linetype = 2) +
  stat_function(fun = line2, linetype = 2) +
  stat_function(fun = line3, linetype = 2) +
  annotate('text', -0.1, 1.05, label = 'a') +
  annotate('text', -0.1, 0.72, label = 'b') +
  annotate('text', -0.1, 0.12, label = 'c') +
  scale_y_continuous(
    'effect size',
    limits = c(-0.1, 1.1), expand = c(0, 0),
    breaks = c(0, 1), labels = c('', '')
  ) +
  scale_x_continuous(
    'intervention scale',
    limits = c(-1.02, 1.6), expand = c(0, 0),
    breaks = c(-1, daycare_x, 0.5, 1.0, 1.5),
    labels = c('individual', 'daycare', 'city', 'state', 'region')
  ) +
  theme_classic() +
  theme(
    axis.text = element_text(color = 'black', size = 10),
    axis.title = element_text(size = 12)
  )

show(concept_plot)

ggsave('fig/concept.pdf', plot = concept_plot,
       width = 88, height = 80, units = 'mm')
```
