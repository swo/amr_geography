---
title: "Empirical use-resistance relationships over geographic scales"
author: "Scott Olesen"
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
  fig.width=7, fig.height=4, fig.path='fig/',
  dev=c('png', 'pdf'),
  echo=FALSE, warning=FALSE, message=FALSE,
  cache=TRUE, autodep=TRUE)
pdf.options(useDingbats=FALSE, useKerning=FALSE)

library(purrr)
```

# US/Europe conversions

Most of the US studies and data are measured in prescriptions (or claims) per 1,000 people per year (PIY); the European studies are usually in DID (DDD per 1,000 people per year). Converting between the two requires asserting how many DDD are in one prescription.

I got these numbers by (1) looking in MarketScan and computing the average days' supply for claims for each drug and (2) comparing the CDDEP's within-US numbers (in PIY) with their across-country values for the US (in DID). They seem to disagree somewhat on the $\beta$-lactams. Something to be looked into a little more.

```{r piy_did}
us_europe_crosswalk = data_frame(
  drug = c('beta_lactam', 'quinolone', 'macrolide'),
  ddd_per_rx = c(10, 10, 7)
)

kable(us_europe_crosswalk)

# PIY = Prescriptions per 1,000 Inhabitants per Year
us_europe_convert = function(drug_, piy) {
  us_europe_crosswalk %$%
    { piy / 365 * ddd_per_rx[match(drug_, drug)] }
}
```

# Medicare & ResistanceOpen

This is a nice chance to ask if going to a smaller scale gives you different regression coefficients. I compare the slopes of the use/resistance relationship when using HRRs and states.

```{r medicare_ro}
ro_bugdrugs = data_frame(
  bug = c('S. pneumoniae', 'S. pneumoniae', 'E. coli'),
  drug_group = c('beta_lactam', 'macrolide', 'quinolone')
)

ro_state = read_tsv('../data/ms-medicare-ro/abg_state.tsv')
ro_hrr = read_tsv('../data/ms-medicare-ro/abg_hrr.tsv')

medicare_state_use = read_tsv('../data/ms-medicare-ro/ineq_medicare_state.tsv')
medicare_hrr_use = read_tsv('../data/ms-medicare-ro/ineq_medicare_hrr.tsv')

medicare_state = inner_join(medicare_state_use, ro_state, by=c('drug_group', 'state')) %>%
  inner_join(ro_bugdrugs) %>%
  mutate(dataset='Medicare (state)',
         pct_res=100*f_ns,
         did = us_europe_convert(drug_group, total_use * 1000)) %>%
  select(dataset, bug, drug=drug_group, geo_unit=state, did, pct_res)

medicare_hrr = inner_join(medicare_hrr_use, ro_hrr, by=c('drug_group', 'hrr')) %>%
  inner_join(ro_bugdrugs) %>%
  mutate(dataset='Medicare (HRR)',
         pct_res=100*f_ns,
         did = us_europe_convert(drug_group, total_use * 1000),
         geo_unit = as.character(hrr)
         ) %>%
  select(dataset, bug, drug=drug_group, geo_unit, did, pct_res)

medicare_state_models = medicare_state %>%
  group_by(bug, drug) %>%
  do(tidy(lm(pct_res ~ did, data=.), conf.int=TRUE)) %>%
  ungroup()

medicare_hrr_models = medicare_hrr %>%
  group_by(bug, drug) %>%
  do(tidy(lm(pct_res ~ did, data=.), conf.int=TRUE)) %>%
  ungroup()
```

```{r ms}
marketscan = read_tsv('~/grad/proj/medicare/analysis/ms2/ineq_marketscan.tsv') %>%
  inner_join(ro_state, by=c('drug_group', 'state')) %>%
  inner_join(ro_bugdrugs) %>%
  mutate(did = us_europe_convert(drug_group, total_use * 1000)) %>%
  mutate(dataset='MarketScan', pct_res=100 * f_ns) %>%
  select(dataset, bug, drug=drug_group, geo_unit=state, did, pct_res)
```

To the eye, it looks like the state and HRR points lie on similar lines:

```{r}
bind_rows(
  medicare_state %>% mutate(level='state'),
  medicare_hrr %>% mutate(level='hrr')
) %>%
  ggplot(aes(did, pct_res, color=level)) +
  facet_wrap(~ bug + drug, scales='free_x') +
  geom_point() +
  geom_smooth(method='lm')
```

Looking at just the regression results emphasizes that:

```{r}
bind_rows(
  medicare_state_models %>% mutate(level='state'),
  medicare_hrr_models %>% mutate(level='hrr')
) %>%
  filter(term == 'did') %>%
  ggplot(aes(level, estimate, ymin=conf.low, ymax=conf.high)) +
  facet_wrap(~ bug + drug) +
  geom_point() +
  geom_errorbar()
```

And I could do something more sophisticated, by running a model $\rho ~ \tau$ and another one $\rho ~ \tau + \tau \times L$, where $L$ is a dummy variable encoding whether the level of the analysis is state or HRR. All those interaction terms are not statistically significant.

```{r}
bind_rows(
  medicare_state %>% mutate(level='state'),
  medicare_hrr %>% mutate(level='hrr')
) %>%
  mutate(at_hrr = as.integer(level == 'hrr')) %>%
  group_by(bug, drug) %>%
  do(tidy(lm(did ~ pct_res * at_hrr, data=.), conf.int=TRUE)) %>%
  select(-std.error, -statistic) %>%
  filter(term == 'pct_res:at_hrr')
```

# Data sets

## Arason

```{r arason}
arason_r = read_tsv('../data/arason/resistance.tsv') %>%
  group_by(area_code) %>%
  summarize_at(vars(starts_with('n')), sum) %>%
  mutate(n_isolates = n_resistant + n_sensitive,
         pct_res = 100 * n_resistant / n_isolates)

arason_u = read_tsv('../data/arason/use.tsv') %>%
  mutate(did = did_penV + did_amoxclav) %>%
  select(area_code, did)

arason = inner_join(arason_r, arason_u, by='area_code') %>%
  mutate(dataset='Arason', bug='S. pneumoniae', drug='beta_lactam') %>%
  select(dataset, bug, drug, geo_unit=area_code, did, pct_res, n_isolates)
```

## Bronzwaer

```{r bronzwaer}
bronzwaer = read_tsv('../data/bronzwaer/use_resistance.tsv') %>%
  mutate(pct_res = 100 * n_nonsusceptible / n_isolates) %>%
  mutate(dataset='Bronzwaer', bug='S. pneumoniae', drug='beta_lactam') %>%
  select(dataset, bug, drug, geo_unit=country, did=did_betalactam, did=did_betalactam, pct_res, n_isolates)
```

## ECDC

```{r ecdc}
rename_bug = function(x) {
  sapply(x, function(y) {
    switch(y, 'Escherichia coli'='E. coli', 'Streptococcus pneumoniae'='S. pneumoniae', y)
  })
}

ecdc = read_tsv('../data/ecdc/data.tsv') %>%
  mutate(bug = rename_bug(bug),
         pct_res = 100 * f_ns,
         dataset='ECDC') %>%
  select(dataset, bug, drug, geo_unit=country, did, n_resistant=n_ns, n_isolates, pct_res)
```

## Pihljamaki

```{r pihljamaki}
pihljamaki_pen = read_tsv('../data/pihljamaki/penicillins.tsv') %>%
  mutate(dataset='Pihljamaki', bug='S. pneumoniae', drug='beta_lactam', geo_unit=as.character(1:n())) %>%
  select(dataset, bug, drug, geo_unit, did=did_pen, pct_res=pct_res_pen)

pihljamaki_macro = read_tsv('../data/pihljamaki/macrolides.tsv') %>%
  mutate(dataset='Pihljamaki', bug='S. pneumoniae', drug='macrolide', geo_unit=as.character(1:n())) %>%
  select(dataset, bug, drug, geo_unit, did=did_macrolide, pct_res=pct_res_erythro)

pihljamaki = bind_rows(pihljamaki_pen, pihljamaki_macro)
```

## Goossens

```{r goossens}
goossens = read_tsv('../data/goossens/data.tsv') %>%
  mutate(dataset='Goossens', bug='S. pneumoniae', drug='beta_lactam') %>%
  select(dataset, bug, drug, geo_unit=country, did, pct_res=pct_nonsusceptible)
```

## Kahlmeter

```{r kalhmeter}
kahlmeter = inner_join(
  read_tsv('../data/kahlmeter/resistance.tsv') %>% filter(drug=='CIP'),
  read_tsv('../data/kahlmeter/use.tsv') %>% group_by(country) %>% summarize(did=mean(did)),
  by='country'
) %>%
  mutate(dataset='Kahlmeter', bug='E. coli', drug='quinolone') %>%
  select(dataset, bug, drug, geo_unit=country, did, pct_res, n_isolates=n)
```

## NHSN/IMS

Requires assuming a 10x conversion factor

```{r nhsn_ims}
nhsn = read_tsv('../data/nhsn-ims/data.tsv') %>%
  mutate(dataset='NHSN/IMS', bug='E. coli', drug='quinolone',
         pct_res = 100 * n_resistant / n_isolates,
         did = us_europe_convert(drug, rx_1k_year)) %>%
  select(dataset, bug, drug, geo_unit=state, did, pct_res, n_isolates)
```

## CDDEP

```{r cddep}
cddep = read_tsv('../data/cddep/use_res.tsv') %>%
  mutate(dataset='CDDEP',
         bug = rename_bug(bug),
         drug_group = if_else(drug_group == 'penicillin', 'beta_lactam', drug_group),
         did = us_europe_convert(drug_group, rx_1k_year)) %>%
  select(dataset, bug, drug=drug_group, geo_unit=division, did, pct_res=pct_resistant)
```

## Garcia-Rey 2002

```{r garcia_rey2002}
gr2_raw = read_tsv('../data/garcia-rey2002/data.tsv') %>%
  select(province, n_isolates,
         did_bl_total, pct_res_pen,
         did_macrolide_total, pct_res_erythro) %>%
  gather('key', 'value', -province)

# use and resistance data
gr2_ur = gr2_raw %>%
  filter(key != 'n_isolates') %>%
  mutate(
    drug = case_when(
      str_detect(.$key, '(bl|pen)') ~ 'beta_lactam',
      str_detect(.$key, '(macrolide|erythro)') ~ 'macrolide',
      TRUE ~ NA_character_),
    metric = case_when(
      str_detect(.$key, 'did') ~ 'did',
      str_detect(.$key, 'pct_res') ~ 'pct_res',
      .$key == 'n_isolates' ~ 'n_isolates'
    )
  ) %>%
  select(-key) %>%
  spread(metric, value)

# number of isolates
gr2_ni = gr2_raw %>%
  filter(key == 'n_isolates') %>%
  select(province, n_isolates=value)

garciarey2002 = inner_join(gr2_ur, gr2_ni, by='province') %>%
  mutate(dataset='Garcia-Rey 2002', bug='S. pneumoniae') %>%
  select(dataset, bug, drug, geo_unit=province, did, pct_res, n_isolates)
```

## Garcia-Rey 2004

Units in the paper are "units per 1,000 inhabitants per year". So clearly need to divide by 365, but I also don't know how to convert "units" to DDD. So I think I should dropp this study, which isn't bad, since I have the 2002 version from the same data stream.

```{r, eval=FALSE}
gr4_raw = read_tsv('../data/garcia-rey2004/data.tsv')

gr4_ni = gr4_raw %>%
  select(province, n_isolates)

gr4_bl = gr4_raw %>%
  mutate(drug = 'beta_lactam',
         pct_res = n_res_pen,
         did = did_beta_lactams / 365) %>%
  select(province, drug, pct_res, did)

gr4_macro = gr4_raw %>%
  mutate(drug = 'macrolide',
         pct_res = n_res_erythro,
         did = did_macrolides / 365) %>%
  select(province, drug, pct_res, did)

garciarey2004 = bind_rows(gr4_bl, gr4_macro) %>%
  left_join(gr4_ni, by='province') %>%
  mutate(did = case_when(
    .$drug == 'beta_lactam' ~ 19 * .$did,
    .$drug == 'macrolide' ~ 7 * .$did
  )) %>%
  mutate(dataset='Garcia-Rey 2004', bug='S. pneumoniae') %>%
  select(dataset, bug, drug, geo_unit=province, did, pct_res, n_isolates)
```

## Combined figure

```{r}
comb = bind_rows(arason, bronzwaer, ecdc, pihljamaki, goossens, kahlmeter, nhsn, cddep, garciarey2002,
                 #medicare_state, medicare_hrr,
                 marketscan) %>%
  mutate(bugdrug = case_when(
    .$bug == 'E. coli' & .$drug == 'quinolone' ~ 'Ec/q',
    .$bug == 'S. pneumoniae' & .$drug == 'beta_lactam' ~ 'Sp/bl',
    .$bug == 'S. pneumoniae' & .$drug == 'macrolide' ~ 'Sp/m'
  ))

data_plot_f = function(bugdrug_) {
  comb %>%
    filter(dataset != 'Medicare (HRR)', bugdrug == bugdrug_) %>%
    ggplot(aes(did, pct_res, color=dataset)) +
    stat_smooth(method='lm', fullrange=TRUE, se=FALSE, size=1) +
    stat_smooth(method='lm', fullrange=TRUE, geom='ribbon', linetype=2, fill=NA) +
    geom_point(shape=1) +
    ggtitle(bugdrug_)
}

data_plot_f('Ec/q')
data_plot_f('Sp/bl')
data_plot_f('Sp/m')
```

```{r}
models = comb %>%
  group_by(dataset, bugdrug) %>%
  do(tidy(lm(pct_res ~ did, data=.), conf.int=TRUE)) %>%
  ungroup()

plot_f_f = function(term_, xlab_) {
  function(bugdrug_) {
    models %>%
      filter(term==term_, bugdrug==bugdrug_) %>%
      mutate(dataset = fct_reorder(factor(dataset), estimate)) %>%
      ggplot(aes(y=dataset, x=estimate, xmin=conf.low, xmax=conf.high)) +
      geom_vline(xintercept=0, color='black', linetype=2) +
      geom_point() + geom_errorbarh() +
      xlab(xlab_) +
      ylab('') +
      ggtitle(bugdrug_)
  }
}

did_plot_f = plot_f_f('did', 'regression coefficient (p.p. resistance / DID)')
intercept_plot_f = plot_f_f('(Intercept)', 'regression intercept (% resistant)')

did_plot_f('Ec/q')
did_plot_f('Sp/bl')
did_plot_f('Sp/m')

intercept_plot_f('Ec/q')
intercept_plot_f('Sp/bl')
intercept_plot_f('Sp/m')
```

## Mixed models

I use mixed models as a way to summarize these data. Each study has an intercept and slope that are drawn from some true populations that we try to estimate.

```{r}
mixed_models = comb %>%
  group_by(bugdrug) %>%
  do(tidy(lme4::lmer(pct_res ~ did + (did | dataset), data=.), conf.int=TRUE)) %>%
  ungroup()

bind_rows(
  models %>% mutate(type = 'study'),
  mixed_models %>% mutate(type = 'summary', dataset='Mixed model')
) %>%
  filter(term == 'did') %>%
  ggplot(aes(y=dataset, x=estimate)) +
  geom_vline(xintercept = 0, color='gray', linetype=2) +
  geom_point(aes(shape=type, size=type)) +
  scale_shape_manual(values=c(16, 18)) +
  scale_size_manual(values=c(2, 6)) +
  geom_errorbarh(aes(xmin=conf.low, xmax=conf.high), height=0.5) +
  facet_grid(type ~ bugdrug, scales='free', space='free_y')
```

There's not enough studies to properly ask whether geographical scale has an effect on the model performance. I think it's better to just do something qualitative, to say that we don't see an obvious signal in these larger studies, but we see, in our stuff, that grouping states into 9-state groups is fine.

# MAUP

## MarketScan

```{r maup_db}
state_census = read_tsv('../db/census/state_census.tsv') %>%
  filter(between(year, 2011, 2014)) %>%
  group_by(state_abbreviation) %>%
  summarize(population = mean(population))

state_data = data_frame(
  state = state.name,
  state_abbreviation = state.abb,
  region = state.region,
  division = state.division,
  long = state.center$x,
  lat = state.center$y
) %>%
  mutate_if(is.factor, as.character) %>%
  inner_join(state_census, by = 'state_abbreviation') %>%
  mutate(unit_id = 1:n())
```

```{r marketscan_maup_data}
marketscan_res = read_tsv('~/grad/proj/medicare/analysis/ms2/data/abg_state.tsv') %>%
  rename(drug=drug_group) %>%
  mutate(bugdrug = case_when(
    .$bug == 'E. coli' & .$drug == 'quinolone' ~ 'Ec/q',
    .$bug == 'S. pneumoniae' & .$drug == 'beta_lactam' ~ 'Sp/bl',
    .$bug == 'S. pneumoniae' & .$drug == 'macrolide' ~ 'Sp/m'
  )) %>%
  filter(!is.na(bugdrug)) %>%
  mutate(n_resistant = as.integer(round(f_ns * n_isolates))) %>%
  select(bugdrug, drug, state, n_resistant, n_isolates)

marketscan_use = read_tsv('~/grad/proj/medicare/analysis/ms2/ineq_marketscan.tsv') %>%
  rename(drug = drug_group) %>%
  filter(drug %in% c('quinolone', 'beta_lactam', 'macrolide')) %>%
  mutate(did = us_europe_convert(drug, total_use * 1000))

marketscan = marketscan_use %>%
  inner_join(marketscan_res, by=c('drug', 'state')) %>%
  select(unit = state, bugdrug, did, n_resistant, n_isolates)
```

```{r marketscan_maup_random}
# group n items into k groups, with at least 1 item in each group
sample1 = function(n, k) {
  stopifnot(n >= k)
  sample(c(1:k, sample(k, n - k, replace = TRUE)))
}

range1 = function(x) max(x) - min(x)

maup_sim = function(ur, unit_data, ks, n_iterations=10, extra_groups=NULL) {
  if (!all(c('unit', 'long', 'lat', 'population') %in% names(unit_data))) {
    stop('missing columns in unit_data')
  }
  if (any(duplicated(unit_data$unit))) stop('duplicated units')
  if (!all(c('unit', 'bugdrug', 'did', 'n_resistant', 'n_isolates') %in% names(ur))) {
    stop('missing columns in use-resistance (ur)')
  }
  
  n_units = nrow(unit_data)
  if (max(ks) > n_units) stop('at least one k is greater than no. units')
  
  if (!is.null(extra_groups)) {
    if (!all(c('k', 'type', 'group') %in% names(extra_groups))) {
      stop('missing columns in extra_groups')
    }
  }
  
  bugdrugs = unique(ur$bugdrug)

  random_samples = function(k) {
    samples = as.character(sample1(n_units, k))
    data_frame(unit = unit_data$unit, group = samples)
  }

  unit_distances = unit_data %>%
    select(long, lat) %>%
    dist() %>%
    as.matrix() %>%
    set_colnames(unit_data$unit) %>%
    set_rownames(unit_data$unit)

  random_zones = function(k) {
    centers = sample(unit_data$unit, k)
    zones = unit_distances[, centers] %>%
      apply(1, function(x) centers[which.min(x)])
    
    data_frame(unit = unit_data$unit, group = zones)
  }
  
  data_f = function(bugdrug_, group_) {
    ur %>%
      left_join(unit_data, by = 'unit') %>%
      filter(bugdrug == bugdrug_) %>%
      left_join(group_, by = 'unit') %>%
      group_by(group) %>%
      summarize(pct_res = sum(n_resistant) / sum(n_isolates) * 100,
                did = weighted.mean(did, w = population))
  }
  
  # iterations for each k
  k_it = crossing(k = ks, iteration = 1:n_iterations)
  
  # add in the sample and zone
  bind_rows(
    k_it %>% mutate(type = 'sample', group = map(k, random_samples)),
    k_it %>% mutate(type = 'zone', group = map(k, random_zones))
  ) %>%
    bind_rows(extra_groups) %>%
    crossing(bugdrug = bugdrugs) %>%
    mutate(data = map2(bugdrug, group, data_f),
           model = map(data, ~ lm(pct_res ~ did, data = .)),
           slope = map_dbl(model, ~ coef(.)[2]),
           cor = map_dbl(data, ~ cor(.$did, .$pct_res)),
           did_range = map_dbl(data, ~ range1(.$did)),
           res_range = map_dbl(data, ~ range1(.$pct_res)))
}
```

```{r}
marketscan_unit_data = state_data %>%
  rename(unit = state) %>%
  filter(unit %in% marketscan$unit)

state_grouping = data_frame(
  k = n_units,
  group = map(1, ~ select(unit_data, unit, group = unit_id))
)

division_grouping = data_frame(
  k = length(unique(unit_data$division)),
  group = map(1, ~ select(unit_data, unit, group = division))
)

region_grouping = data_frame(
  k = length(unique(unit_data$region)),
  group = map(1, ~ select(unit_data, unit, group = region))
)

census_groups = bind_rows(state_grouping, division_grouping, region_grouping) %>%
  mutate(type = 'actual')

marketscan_ks = c(4, 9, 20, 30, 40)
marketscan_maup = maup_sim(marketscan, marketscan_unit_data, marketscan_ks,
                           extra_groups = census_groups)
```

```{r}
marketscan_maup %>%
  select(k, iteration, type, bugdrug, slope, cor) %>%
  gather('metric', 'estimate', slope, cor) %>%
  ggplot(aes(factor(k), estimate, color=type)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(metric ~ bugdrug, scales='free_y')

# swo:
# - add invisible data to get all factor levels
# - only THEN plot the "actual" data, w/o boxplots

ex4 = marketscan_maup %>%
  filter(k == 4, type == 'zone') %>%
  group_by(bugdrug) %>%
  filter(cor %in% c(min(cor), max(cor))) %>%
  mutate(extremum = if_else(cor == max(cor), 'max', 'min')) %>%
  ungroup()

ex4 %>%
  select(bugdrug, extremum, data) %>%
  unnest() %>%
  ggplot(aes(did, pct_res)) +
  geom_point() +
  stat_smooth(method = 'lm', se = FALSE) +
  facet_grid(extremum ~ bugdrug, scales='free')
  
map_f = function(group_) {
  state_map %>%
    left_join(group_, by = 'unit') %>%
    ggplot(aes(long, lat, group = map_group, fill = group)) +
    geom_polygon(color = 'black') +
    coord_map() +
    theme(legend.position = 'none',
          axis.title.x = element_blank(),
          axis.title.y = element_blank())
}

ex4 %>%
  mutate(plot = map(group, map_f)) %>%
  pull(plot) %>%
  { ggpubr::ggarrange(plotlist = .) }
```

## Using IMS/NHSN

```{r}
nhsn = read_tsv('../data/nhsn-ims/data.tsv') %>%
  rename(state_abbreviation = state) %>%
  filter(state_abbreviation %in% state.abb) %>%
  mutate(state_id = match(state_abbreviation, state.abb),
         state = state.name[state_id],
         bugdrug = 'Ec/q',
         did = us_europe_convert('quinolone', rx_1k_year)) %>%
  select(unit = state, bugdrug, did, n_resistant, n_isolates)

nhsn_unit_data = state_data %>%
  rename(unit = state) %>%
  filter(unit %in% nhsn$unit)

nhsn_extra_groups = data_frame(
  k = 50,
  type = 'actual',
  group = map(1, ~ select(nhsn_unit_data, unit, group = unit_id))
)

nhsn_maup = maup_sim(nhsn, nhsn_unit_data, c(4, 9, 20, 30, 40),
                     extra_groups = nhsn_extra_groups)
```

```{r}
nhsn_maup %>%
  select(k, iteration, type, bugdrug, slope, cor) %>%
  gather('metric', 'estimate', slope, cor) %>%
  ggplot(aes(factor(k), estimate, color=type)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(metric ~ bugdrug, scales='free_y')
```

## Europe

```{r}
europe = read_tsv('../data/ecdc/data.tsv') %>%
  mutate(bugdrug = case_when(
    .$bug == 'Escherichia coli' & .$drug == 'quinolone' ~ 'Ec/q',
    .$bug == 'Streptococcus pneumoniae' & .$drug == 'beta_lactam' ~ 'Sp/bl',
    .$bug == 'Streptococcus pneumoniae' & .$drug == 'macrolide' ~ 'Sp/m'
  )) %>%
  left_join(select(europe_centers, country, population), by='country') %>%
  select(unit = country, bugdrug, did, n_resistant = n_ns, n_isolates)

europe_units = read_tsv('../db/europe_centers/europe_centers.tsv') %>%
  filter(country %in% europe$unit) %>%
  mutate(unit_id = 1:n()) %>%
  select(unit = country, long = longitude, lat = latitude, population, unit_id)

europe_extra = data_frame(
  k = nrow(europe_units),
  type = 'actual',
  group = map(1, ~ select(europe_units, unit, group = unit_id))
)

europe_maup = maup_sim(europe, europe_units, ks = c(5, 10, 15, 20),
                       extra_groups = europe_extra)
```

```{r}
europe_maup %>%
  select(k, iteration, type, bugdrug, slope, cor) %>%
  gather('metric', 'estimate', slope, cor) %>%
  ggplot(aes(factor(k), estimate, color=type)) +
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(metric ~ bugdrug, scales='free_y')
```

## Simulations

Here I imagine I have $N = 50$ states with uses uniformly distributed between 0 and $u_\mathrm{max} = 1$. Some slope $m \in [0, 0.1, 1, 10]$ connects use with resistance, which is subject to variance $\sigma = 1$. If I randomly aggregate or zone states into $k$ groups, averaging use and resistance in each group, how do the measured use-resistance slopes $\hat{m}$ compare to the actual $m$?

Both types of aggregation appear to give unbiased estimates for $m$. The variance of the random aggregates increases with the size of the aggregates, but only substantially so for small $k$. The standard errors in the measured slopes increases for both zones and random samples, but the effect is especially acute for the random samples. This makes it look like going to larger aggregates is a pretty bad way to find a use-resistance relationship!

```{r maup_abstract_sim}
which_nearest = function(x, vals) {
  outer(x, vals, FUN=function(x, y) abs(x - y)) %>%
    apply(1, which.min)
}

sim_lm = function(slope, k, n_units=50, use_max=1, sigma=1) {
  use = runif(n_units, 0, use_max)
  res = use * slope + rnorm(n_units, 0, sigma)
  
  # random sample grouping
  sample_group = sample1(n_units, k)
  sample_model = data_frame(use=use, res=res, g=sample_group) %>%
    group_by(g) %>%
    summarize_at(vars(use, res), mean) %>%
    lm(res ~ use, data=.) %>%
    tidy(conf.int=TRUE) %>%
    mutate(type = 'sample')
  
  # random zone grouping
  centers = sample(use, size = k, replace = FALSE)
  zones = which_nearest(use, centers)
  zone_model = data_frame(use=use, res=res, g=zones) %>%
    group_by(g) %>%
    summarize_at(vars(use, res), mean) %>%
    lm(res ~ use, data=.) %>%
    tidy(conf.int=TRUE) %>%
    mutate(type = 'zone')
  
  bind_rows(sample_model, zone_model)
}

sim_group = crossing(k = c(5, 10, 25, 50),
         slope = c(0, 0.1, 1, 10),
         iteration = 1:100) %>%
  group_by_all() %>%
  do(sim_lm(.$slope, .$k)) %>%
  ungroup()
```

```{r}
sim_group %>%
  filter(term == 'use') %>%
  ggplot(aes(factor(k), estimate)) +
  geom_hline(aes(yintercept = slope), color='gray') +
  geom_boxplot(aes(color=type)) +
  facet_wrap(~ slope, scales='free_y')
```
