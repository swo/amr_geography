---
title: "Geography and associations between antibiotic use and resistance: observational data"
author: "Scott Olesen"
---

```{r global_options, echo = FALSE, message = FALSE}
library(knitr)
library(cowplot)
library(tidyverse)

knitr::opts_chunk$set(
  echo = FALSE, warning = FALSE, message = FALSE,
  cache = TRUE, autodep = TRUE
)

pdf.options(useDingbats = FALSE, useKerning = FALSE)
```

# Load data

```{r state_data}
state_temp <- read_tsv('../db/us/temperature.tsv')
state_income <- read_tsv('../db/us/income.tsv')
state_density <- read_tsv('../db/us/density.tsv')

state_data <- state_temp %>%
  left_join(state_income, by = 'state') %>%
  left_join(state_density, by = 'state')
```

```{r marketscan_data}
marketscan_res = read_tsv('../data/ms-medicare-ro/abg_state.tsv') %>%
  rename(drug = drug_group) %>%
  mutate(bugdrug = case_when(
    # don't do Sp/bl, as they have negative correlation
    .$bug == 'E. coli' & .$drug == 'quinolone' ~ 'Ec/q',
    .$bug == 'S. pneumoniae' & .$drug == 'macrolide' ~ 'Sp/m'
  )) %>%
  filter(!is.na(bugdrug)) %>%
  select(bugdrug, drug, state, f_resistant = f_ns)

marketscan_use <- read_tsv('../data/ms-medicare-ro/ineq_marketscan.tsv') %>%
  rename(drug = drug_group, use = total_use) %>%
  filter(drug %in% c('quinolone', 'beta_lactam', 'macrolide'))

marketscan <- marketscan_use %>%
  inner_join(marketscan_res, by = c('drug', 'state')) %>%
  left_join(state_data, by = 'state') %>%
  select(
    unit = state, bugdrug, use, f_resistant,
    density, income, temperature
  )
```

```{r nhsn_ims}
nhsn <- read_tsv('../data/nhsn-ims/data.tsv') %>%
  rename(state_abbreviation = state) %>%
  filter(state_abbreviation %in% state.abb) %>%
  mutate(
    state = state.name[match(state_abbreviation, state.abb)],
    bugdrug = 'Ec/q',
    use = rx_1k_year / 1e3,
    f_resistant = n_resistant / n_isolates
  ) %>%
  left_join(state_data, by = 'state') %>%
  select(
    unit = state, bugdrug, use, f_resistant,
    density, income, temperature
  )
```

For the European data, we convert to "treatments" per person per year, assuming a certain conversion from DDD to treatments. This is just an *ad hoc* adjustment to get the European data to the same scales as used in the simulations and the US data.

```{r ecdc_convert}
did_cpy_map <- tibble(
  drug = c('beta_lactam', 'quinolone', 'macrolide'),
  ddd_per_tx = c(10, 10, 7),
  cpy_per_did = 365 / (1e3 * ddd_per_tx)
)

did_cpy_map %>%
  kable(caption = 'DDD to treatment conversion')
```

```{r ecdc}
europe_temp <- read_tsv('../db/europe/temperature.tsv')
europe_income <- read_tsv('../db/europe/income.tsv')
europe_density <- read_tsv('../db/europe/density.tsv')

europe_data <- europe_temp %>%
  left_join(europe_income, by = 'country') %>%
  left_join(europe_density, by = 'country')

europe <- read_tsv('../data/ecdc/data.tsv') %>%
  left_join(did_cpy_map, by = 'drug') %>%
  mutate(use = cpy_per_did * did) %>%
  mutate(
    bugdrug = case_when(
      .$bug == 'Escherichia coli' & .$drug == 'quinolone' ~ 'Ec/q',
      .$bug == 'Streptococcus pneumoniae' & .$drug == 'beta_lactam' ~ 'Sp/bl',
      .$bug == 'Streptococcus pneumoniae' & .$drug == 'macrolide' ~ 'Sp/m'
    ),
    f_resistant = n_ns / n_isolates
  ) %>%
  left_join(europe_data, by = 'country') %>%
  rename(unit = country) %>%
  select(
    unit, bugdrug, use, f_resistant,
    density, temperature, income
  )

eu_units <- unique(europe$unit)
```

```{r combine_data}
named_bind_rows = function(..., label = 'dataset') {
  names = map_chr(quos(...), quo_name)
  map2_dfr(list(...), names, ~ mutate(.x, !!as.symbol(label) := .y))
}

unit_data = named_bind_rows(marketscan, nhsn, europe) %>%
  select(dataset, bugdrug, unit, f_resistant, use, density, temperature, income) %>%
  nest(-dataset, -bugdrug)
```

```{r adjacency_db}
us_adjacency <- read_tsv('../db/us/adjacency.tsv') %>%
  mutate(adjacent = TRUE) %>%
  complete(state1, state2) %>%
  replace_na(list(adjacent = FALSE)) %>%
  rename(unit1 = state1, unit2 = state2)

eu_adjacency <- read_tsv('../db/europe_adjacency.tsv') %>%
  mutate(adjacent = TRUE) %>%
  right_join(crossing(unit1 = europe_names, unit2 = europe_names)) %>%
  replace_na(list(adjacent = FALSE))

adjacency_db <- bind_rows(us_adjacency, eu_adjacency)

# swo: need to mirror this, based on how the crossing function is written
us_commuting <- read_tsv('../db/us/commuting.tsv') %>%
  rename_all(~ str_replace(., '^state', 'unit')) %>%
  mutate(dataset = 'US')

eu_commuting <- read_tsv('../db/europe/commuting.tsv') %>%
  rename_all(~ str_replace(., '^country', 'unit')) %>%
  filter(unit1 %in% eu_units, unit2 %in% eu_units) %>%
  mutate(dataset = 'Europe')

commuting_db <- bind_rows(us_commuting, eu_commuting)
```

# Commuting histogram

```{r commuting_histogram}
commuting_db %>%
  filter(unit1 > unit2) %>%
  ggplot(aes(x = log10(f_commuting))) +
  facet_wrap(~ dataset, scales = 'free_y') +
  geom_histogram(fill = 'black') +
  xlab('Commuting fraction (log 10)') +
  ylab('Number of state pairs') +
  theme_half_open() +
  theme(strip.background = element_blank())
```

# Adjacency analysis

```{r distance_analysis_helpers}
odds <- function(p) p / (1 - p)
log_odds_ratio <- function(p, q) log(odds(p)) - log(odds(q))

cross_units <- function(df) {
  df %>%
    with(crossing(unit1 = unit, unit2 = unit)) %>%
    filter(unit1 < unit2) %>%
    left_join(rename_all(df, ~ str_c(., '1')), by = 'unit1') %>%
    left_join(rename_all(df, ~ str_c(., '2')), by = 'unit2') %>%
    mutate(
      d_resistant = f_resistant1 - f_resistant2,
      d_use = use1 - use2,
      d_income = income1 - income2,
      d_density = density1 - density2,
      d_temperature = temperature1 - temperature2,
      dr_du = d_resistant / d_use,
      lor_resistant = log_odds_ratio(f_resistant1, f_resistant2),
      lorr_du = lor_resistant / d_use
    ) %>%
    select(unit1, unit2, starts_with('d_'), dr_du, starts_with('lor')) %>%
    left_join(adjacency_db, by = c('unit1', 'unit2')) %>%
    left_join(commuting_db, by = c('unit1', 'unit2'))
}

permute_cross_units <- function(df) {
  df %>%
    mutate(f_resistant = sample(f_resistant)) %>%
    cross_units()
}

# Jackknife to build confidence interval
jackknife_se <- function(df, stat) {
  bootstrap::jackknife(
    1:nrow(df),
    function(idx) {
      df %>%
        slice(idx) %>%
        cross_units() %>%
        stat()
    }
  )$jack.se
}

# Permute for hypothesis testing
permute_p <- function(df, stat, n_trials, alternative) {
  stopifnot(alternative %in% c('less', 'greater'))
  comp <- switch(alternative, 'greater' = `>`, 'less' = `<`)
  
  base_stat <- stat(cross_units(df))
  results <- replicate(n_trials, stat(permute_cross_units(df)))

  n_exceptional <- sum(comp(results, base_stat))
  (n_exceptional + 1) / (n_trials + 1)
}

adjacency_analysis <- function(unit_data, jackknife_stat, permute_stat = NULL, alternative = 'less', n_trials = 1e3 - 1, alpha = 0.05) {
  if (is.null(permute_stat)) permute_stat <- jackknife_stat
  se_multiplier <- qnorm(1 - alpha / 2)
  
  unit_data %>%
    mutate(
      base_data = map(data, cross_units),
      estimate = map_dbl(base_data, jackknife_stat),
      std_error = map_dbl(data, ~ jackknife_se(., jackknife_stat)),
      cil = estimate - std_error * se_multiplier,
      ciu = estimate + std_error * se_multiplier,
      p_value = map_dbl(data, ~ permute_p(., permute_stat, n_trials, alternative))
    )
}
```

```{r adjacency_analysis}
median_by_adjacency <- function(df, metric) {
  df[[metric]] %>%
    { median(.[!df$adjacent]) - median(.[df$adjacent]) }
}

adjacency_results <- adjacency_analysis(
  unit_data,
  function(df) median_by_adjacency(df, 'dr_du'),
  function(df) with(df, wilcox.test(dr_du[adjacent], dr_du[!adjacent])$statistic)
)

adjacency_results_lorru <- adjacency_analysis(
  unit_data,
  function(df) median_by_adjacency(df, 'lorr_du'),
  function(df) with(df, wilcox.test(lorr_du[adjacent], lorr_du[!adjacent])$statistic)
)
```

## Using $\Delta \rho / \Delta \tau$

```{r adjacency_results}
sigfig <- function(x, n = 2) {
  formatC(signif(x, digits = n), digits = n, format = "fg", flag = "#")
}

adjacency_results_table <- function(df, metric, caption = NULL) {
  df %>%
    mutate(
      adjacent = map_dbl(base_data, ~ median(.[[metric]][.$adjacent == 1])),
      not_adjacent = map_dbl(base_data, ~ median(.[[metric]][.$adjacent == 0])),
      sig = p.adjust(p_value, 'BH') < 0.05
    ) %>%
    select(dataset, bugdrug, adjacent, not_adjacent, estimate, cil, ciu, p_value, sig) %>%
    mutate_if(is.numeric, sigfig) %>%
    kable(caption = caption)
}

adjacency_results %>%
  adjacency_results_table('dr_du', 'Median associations (dr/du) by adjacency, and differences in median associations (with jackknife CIs), and permutation test p-values')
```

```{r adjacency_plot}
boxplot_data_f <- function(df, ymin, ymax) {
  df %>%
    nest(-adjacent) %>%
    mutate(
      y = map(data, ~ .$dr_du),
      box = map(y, ~ boxplot.stats(.)$stats),
      boxplot_data = map(box, ~ tibble(
        ymin = max(.[1], ymin),
        lower = .[2],
        middle = .[3],
        upper = .[4],
        ymax = min(.[5], ymax)
      ))
    ) %>%
    select(adjacent, boxplot_data) %>%
    unnest()
}

f_to_keep <- 0.90
half_drop <- (1 - f_to_keep) / 2

plot_data <- adjacency_results %>%
  mutate(
    y = map(base_data, ~ .$dr_du),
    ymin = map_dbl(y, ~ quantile(., half_drop)),
    ymax = map_dbl(y, ~ quantile(., 1 - half_drop)),
    boxplot_data = pmap(list(base_data, ymin, ymax), boxplot_data_f),
    point_data = pmap(list(base_data, ymin, ymax), ~ filter(..1, between(dr_du, ..2, ..3))),
    # some plotting niceties
    dataset = recode(dataset,
      'europe' = 'ECDC',
      'marketscan' = 'MarketScan/RO',
      'nhsn' = 'Xponent/NHSN'
    ),
    label = str_c(dataset, ' ', bugdrug)
  )

point_data <- plot_data %>%
  select(label, point_data) %>%
  unnest()

boxplot_data <- plot_data %>%
  select(label, boxplot_data) %>%
  unnest()

plot <- ggplot(data = NULL, aes(x = factor(adjacent))) +
  facet_wrap(~ label, scales = 'free_y') +
  geom_boxplot(
    data = boxplot_data,
    aes(lower = lower, upper = upper, middle = middle, ymin = ymin, ymax = ymax),
    stat = 'identity'
  ) +
  geom_jitter(data = point_data, aes(y = dr_du), size = 0.1, width = 0.2) +
  scale_x_discrete(
    '',
    labels = c(`TRUE` = 'Adjacent', `FALSE` = 'Not adj.')
  ) +
  ylab(expression(paste('Use-resistance association ', (Delta * rho / Delta * tau)))) +
  #theme_classic() +
  theme_cowplot() +
  theme(strip.background = element_blank())

show(plot)
ggsave('fig/adjacency_plot.pdf', plot = plot)
```

## Using log odds ratio resistance

```{r}
adjacency_results_lorru %>%
  adjacency_results_table('lorr_du', 'Median associations (LOR(r)/du) by adjacency, and differences in median associations (with jackknife CIs), and permutation test p-values')
```

# Adjacency with covariates

## $\Delta \rho / \Delta \tau$

```{r adjacency_covariates_analysis}
bisquare <- partial(MASS::rlm, psi = MASS::psi.bisquare, maxit = 30)

model_f <- function(data) {
  model <- bisquare(d_resistant ~ d_use * adjacent + d_income + d_density + d_temperature, data = data)
  coef(model)['d_use:adjacentTRUE']
}

adjacency_covariates_results <- adjacency_analysis(unit_data, model_f)
```

```{r}
interaction_term_table <- function(df, caption = NULL) {
  df %>%
    mutate(sig = p.adjust(p_value, 'BH') < 0.05) %>%
    select(dataset, bugdrug, estimate, cil, ciu, p_value, sig) %>%
    mutate_if(is.numeric, sigfig) %>%
    kable(caption = caption)
}

adjacency_covariates_results %>%
  interaction_term_table('Regression interaction term, adjacency with covariates, dr/dt')
```

## Log odds ratio resistance

```{r adjacency_covariates_lor_analysis}
model_f <- function(data) {
  model <- bisquare(lor_resistant ~ d_use * adjacent + d_income + d_density + d_temperature, data = data)
  coef(model)['d_use:adjacentTRUE']
}

adjacency_covariates_lor_results <- adjacency_analysis(unit_data, model_f)
```

```{r}
adjacency_covariates_lor_results %>%
  interaction_term_table('Regrssion interaction term, adjacency with covariates, LOR')
```

# Commuting analysis

## $\Delta \rho / \Delta \tau$

```{r commuting_analysis}
commute_stat <- function(data) {
  model <- bisquare(d_resistant ~ d_use * f_commuting, data = data)
  coef(model)['d_use:f_commuting']
}

commute_results <- adjacency_analysis(
  filter(unit_data, dataset != 'europe'),
  commute_stat
)
```

```{r}
commute_results %>%
  interaction_term_table('Interaction term, commuting without covariates, dr/dt')
```

## Log odds ratio resistance

```{r commuting_lor}
commute_stat_lor <- function(data) {
  model <- bisquare(lor_resistant ~ d_use * f_commuting, data = data)
  coef(model)['d_use:f_commuting']
}

commute_results_lor <- adjacency_analysis(
  filter(unit_data, dataset != 'europe'),
  commute_stat_lor
)
```

```{r}
commute_results_lor %>%
  interaction_term_table('Interaction term, commuting without covariates, LOR')
```

```{r commute_plot}
not_crazy <- function(x) between(x, quantile(x, 0.025), quantile(x, 0.975))

plot <- unit_data %>%
  filter(dataset != 'europe') %>%
  mutate(
    data = map(data, cross_units),
    data = map(data, ~ filter(., not_crazy(dr_du))),
    dataset = recode(dataset,
      'europe' = 'ECDC',
      'marketscan' = 'MarketScan/RO',
      'nhsn' = 'Xponent/NHSN'
    ),
    label = str_c(dataset, ' ', bugdrug)
  ) %>%
  unnest() %>%
  ggplot(aes(f_commuting, dr_du)) +
  facet_wrap(~ label) +
  geom_hline(yintercept = 0, color = 'gray', size = 1) +
  geom_point(shape = 1, size = 0.75) +
  scale_x_log10(
    'Proportion of workers commuting between states',
    breaks = scales::trans_breaks("log10", function(x) 10^x),
    labels = scales::trans_format("log10", scales::math_format(10^.x))
  ) +
  ylab(expression(paste('Use-resistance association ', (Delta * rho / Delta * tau)))) +
  cowplot::theme_cowplot() +
  theme(
    strip.background = element_blank()
  )

show(plot)
ggsave('fig/commute_plot.pdf', plot = plot)
```

# Commuting with covariates

## $\Delta \rho / \Delta \tau$

```{r commuting_analysis_cv}
commute_cv <- function(data) {
  model <- bisquare(d_resistant ~ d_use * f_commuting + d_density + d_income + d_temperature, data = data)
  coef(model)['d_use:f_commuting']
}

commute_cv_lor <- function(data) {
  model <- bisquare(lor_resistant ~ d_use * f_commuting + d_density + d_income + d_temperature, data = data)
  coef(model)['d_use:f_commuting']
}

commuting_results_cv <- unit_data %>%
  filter(dataset != 'europe') %>%
  adjacency_analysis(commute_cv)
```

```{r}
commuting_results_cv %>%
  interaction_term_table('Interaction coefficient, commuting with covariates, dr/dt')
```

## Log odds ratio resistance

```{r, eval = FALSE}
commuting_results_cv_lor <- unit_data %>%
  filter(dataset != 'europe') %>%
  adjacency_analysis(commute_cv_lor)

commuting_results_cv_lor %>%
  mutate(sig = p.adjust(p_value, 'BH') < 0.05) %>%
  select(dataset, bugdrug, estimate, cil, ciu, p_value, sig) %>%
  mutate_if(is.numeric, ~ round(., 2))
```
